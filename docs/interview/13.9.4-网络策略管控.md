# 网络策略管控

## 1. 功能概述

### 1.1 网络策略
使用 Kubernetes NetworkPolicy 控制 VM 的网络流量，实现访问控制和流量限制。

**使用场景**:
- 网络隔离
- 访问控制
- 流量限制
- 安全策略

### 1.2 功能类型
- **访问控制**: 控制哪些 Pod/VM 可以访问
- **端口控制**: 控制哪些端口可以访问
- **流量限流**: 限制出入站流量
- **安全策略**: 实现安全规则

## 2. 当前实现状态

### 2.1 已实现
- ❌ 无网络策略功能

### 2.2 待实现
- ❌ **NetworkPolicy创建**: 自动创建 NetworkPolicy
- ❌ **访问控制列表**: 细粒度访问控制
- ❌ **流量限流**: 出入站流量限流
- ❌ **安全策略**: 安全规则配置

## 3. 技术实现

### 3.1 NetworkPolicy 实现

```go
// pkg/network/policy.go

type NetworkPolicySpec struct {
    // Enabled 是否启用网络策略
    Enabled bool `json:"enabled"`
    
    // IngressRules 入站规则
    // +optional
    IngressRules []IngressRule `json:"ingressRules,omitempty"`
    
    // EgressRules 出站规则
    // +optional
    EgressRules []EgressRule `json:"egressRules,omitempty"`
    
    // PolicyTypes 策略类型: Ingress, Egress, 或两者
    // +optional
    PolicyTypes []string `json:"policyTypes,omitempty"`
}

type IngressRule struct {
    // From 允许访问的来源
    // +optional
    From []NetworkPolicyPeer `json:"from,omitempty"`
    
    // Ports 允许访问的端口
    // +optional
    Ports []NetworkPolicyPort `json:"ports,omitempty"`
}

type EgressRule struct {
    // To 允许访问的目标
    // +optional
    To []NetworkPolicyPeer `json:"to,omitempty"`
    
    // Ports 允许访问的端口
    // +optional
    Ports []NetworkPolicyPort `json:"ports,omitempty"`
}

type NetworkPolicyPeer struct {
    // PodSelector Pod 选择器
    // +optional
    PodSelector *metav1.LabelSelector `json:"podSelector,omitempty"`
    
    // NamespaceSelector 命名空间选择器
    // +optional
    NamespaceSelector *metav1.LabelSelector `json:"namespaceSelector,omitempty"`
    
    // IPBlock IP 块（CIDR）
    // +optional
    IPBlock *IPBlock `json:"ipBlock,omitempty"`
}

type NetworkPolicyPort struct {
    // Protocol 协议: TCP, UDP
    Protocol string `json:"protocol,omitempty"`
    
    // Port 端口号
    Port *intstr.IntOrString `json:"port,omitempty"`
}

func CreateNetworkPolicy(ctx context.Context, c client.Client, vmName, namespace string, spec NetworkPolicySpec) error {
    policy := &networkingv1.NetworkPolicy{
        ObjectMeta: metav1.ObjectMeta{
            Name:      fmt.Sprintf("%s-network-policy", vmName),
            Namespace: namespace,
        },
        Spec: networkingv1.NetworkPolicySpec{
            PodSelector: metav1.LabelSelector{
                MatchLabels: map[string]string{
                    "kubevirt.io/vm": vmName,
                },
            },
            PolicyTypes: buildPolicyTypes(spec.PolicyTypes),
            Ingress:     buildIngressRules(spec.IngressRules),
            Egress:      buildEgressRules(spec.EgressRules),
        },
    }
    
    return c.Create(ctx, policy)
}
```

### 3.2 流量限流实现

```go
// pkg/network/rate_limit.go

type RateLimitSpec struct {
    // Enabled 是否启用限流
    Enabled bool `json:"enabled"`
    
    // IngressLimit 入站限流（Mbps）
    // +optional
    IngressLimit *string `json:"ingressLimit,omitempty"`
    
    // EgressLimit 出站限流（Mbps）
    // +optional
    EgressLimit *string `json:"egressLimit,omitempty"`
}

// 注意：Kubernetes NetworkPolicy 不支持流量限流
// 需要使用 CNI 插件（如 Cilium）或其他工具实现
func ApplyRateLimit(ctx context.Context, c client.Client, vmName, namespace string, spec RateLimitSpec) error {
    // 方案一：使用 Cilium NetworkPolicy（如果使用 Cilium CNI）
    // 方案二：使用自定义资源（如 TrafficPolicy）
    // 方案三：在节点层面使用 tc (traffic control)
    
    return nil
}
```

## 4. API 设计

### 4.1 WukongSpec 扩展

```go
// api/v1alpha1/wukong_types.go

type NetworkConfig struct {
    // ... 现有字段 ...
    
    // NetworkPolicy 网络策略配置（可选）
    // +optional
    NetworkPolicy *NetworkPolicySpec `json:"networkPolicy,omitempty"`
    
    // RateLimit 流量限流配置（可选）
    // +optional
    RateLimit *RateLimitSpec `json:"rateLimit,omitempty"`
}

type NetworkPolicySpec struct {
    // Enabled 是否启用网络策略
    Enabled bool `json:"enabled"`
    
    // IngressRules 入站规则
    // +optional
    IngressRules []IngressRuleSpec `json:"ingressRules,omitempty"`
    
    // EgressRules 出站规则
    // +optional
    EgressRules []EgressRuleSpec `json:"egressRules,omitempty"`
}
```

### 4.2 Controller 实现

```go
// internal/controller/wukong_controller.go

func (r *WukongReconciler) reconcileNetworkPolicy(ctx context.Context, vmp *vmv1alpha1.Wukong) error {
    logger := log.FromContext(ctx)
    vmName := fmt.Sprintf("%s-vm", vmp.Name)
    
    // 检查是否需要创建 NetworkPolicy
    var policySpec *vmv1alpha1.NetworkPolicySpec
    for _, net := range vmp.Spec.Networks {
        if net.NetworkPolicy != nil && net.NetworkPolicy.Enabled {
            policySpec = net.NetworkPolicy
            break
        }
    }
    
    if policySpec == nil {
        // 删除现有的 NetworkPolicy（如果存在）
        return r.deleteNetworkPolicy(ctx, vmName, vmp.Namespace)
    }
    
    // 创建或更新 NetworkPolicy
    policy := &networkingv1.NetworkPolicy{}
    key := client.ObjectKey{Name: fmt.Sprintf("%s-network-policy", vmName), Namespace: vmp.Namespace}
    
    if err := r.Get(ctx, key, policy); err != nil {
        if errors.IsNotFound(err) {
            // 创建新 NetworkPolicy
            return r.createNetworkPolicy(ctx, vmName, vmp, policySpec)
        }
        return err
    }
    
    // 更新现有 NetworkPolicy
    return r.updateNetworkPolicy(ctx, policy, policySpec)
}
```

## 5. 使用示例

### 5.1 基本访问控制
```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: secured-vm
spec:
  networks:
  - name: eth0
    type: bridge
    networkPolicy:
      enabled: true
      ingressRules:
      - from:
        - podSelector:
            matchLabels:
              app: web
        ports:
        - protocol: TCP
          port: 80
      egressRules:
      - to:
        - namespaceSelector:
            matchLabels:
              name: default
        ports:
        - protocol: TCP
          port: 443
```

### 5.2 IP 块访问控制
```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: restricted-vm
spec:
  networks:
  - name: eth0
    type: bridge
    networkPolicy:
      enabled: true
      ingressRules:
      - from:
        - ipBlock:
            cidr: "192.168.1.0/24"
            except:
            - "192.168.1.100/32"
        ports:
        - protocol: TCP
          port: 22
```

### 5.3 流量限流（如果支持）
```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: rate-limited-vm
spec:
  networks:
  - name: eth0
    type: bridge
    rateLimit:
      enabled: true
      ingressLimit: "100Mbps"
      egressLimit: "50Mbps"
```

## 6. 注意事项

### 6.1 CNI 支持
- NetworkPolicy 需要 CNI 插件支持
- Calico、Cilium、Weave 等支持
- Flannel 不支持 NetworkPolicy

### 6.2 流量限流
- Kubernetes NetworkPolicy 不支持流量限流
- 需要使用 Cilium 或其他工具
- 可能需要在节点层面实现

### 6.3 策略冲突
- 多个 NetworkPolicy 可能冲突
- 需要合理设计策略规则
- 提供策略验证机制

## 7. 面试要点

### 7.1 NetworkPolicy 的工作原理？

**答案**:
- 基于 Pod 选择器匹配 Pod
- 定义入站和出站规则
- CNI 插件实现实际的流量控制
- 默认拒绝所有流量（如果启用策略）

### 7.2 如何实现流量限流？

**答案**:
- 使用 Cilium NetworkPolicy（如果使用 Cilium）
- 使用自定义 TrafficPolicy 资源
- 在节点层面使用 tc (traffic control)
- 使用服务网格（如 Istio）实现限流

### 7.3 NetworkPolicy 的限制？

**答案**:
- 需要 CNI 插件支持
- 不支持流量限流（需要额外工具）
- 只能控制 Pod 级别流量
- 某些 CNI 插件可能不支持所有功能

