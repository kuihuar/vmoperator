# PVC 管理详解

## 1. ReconcilePVC 函数

### 1.1 函数签名

```go
func ReconcilePVC(ctx context.Context, c client.Client, disk vmv1alpha1.DiskConfig, namespace, vmName string) (string, bool, error)
```

**返回值**:
- `string`: PVC 名称
- `bool`: 是否已绑定
- `error`: 错误信息

### 1.2 处理流程

```go
func ReconcilePVC(ctx context.Context, c client.Client, disk vmv1alpha1.DiskConfig, namespace, vmName string) (string, bool, error) {
    // 1. 生成 PVC 名称
    pvcName := fmt.Sprintf("%s-%s", vmName, disk.Name)
    
    // 2. 解析存储大小
    storageQuantity, err := resource.ParseQuantity(disk.Size)
    
    // 3. 创建 PVC 对象
    pvc := &corev1.PersistentVolumeClaim{
        Spec: corev1.PersistentVolumeClaimSpec{
            AccessModes: []corev1.PersistentVolumeAccessMode{corev1.ReadWriteOnce},
            Resources: corev1.VolumeResourceRequirements{
                Requests: corev1.ResourceList{
                    corev1.ResourceStorage: storageQuantity,
                },
            },
            StorageClassName: &disk.StorageClassName,
        },
    }
    
    // 4. 检查 PVC 是否存在
    // 5. 如果不存在，创建新的
    // 6. 如果存在，检查绑定状态
    // 7. 处理 WaitForFirstConsumer 模式
}
```

## 2. PVC 命名规则

```go
pvcName := fmt.Sprintf("%s-%s", vmName, disk.Name)
```

**示例**:
- Wukong: `web-server-01`
- Disk: `system`
- PVC: `web-server-01-vm-system`

## 3. WaitForFirstConsumer 模式

### 3.1 模式说明

`WaitForFirstConsumer` 是 StorageClass 的 `volumeBindingMode`，表示：
- PVC 不会立即绑定
- 只有在第一个 Pod 使用该 PVC 时才绑定
- 适合需要节点亲和性的场景

### 3.2 处理逻辑

```go
// 检查 StorageClass 的 volumeBindingMode
sc := &storagev1.StorageClass{}
if sc.VolumeBindingMode != nil && *sc.VolumeBindingMode == storagev1.VolumeBindingWaitForFirstConsumer {
    // WaitForFirstConsumer 模式：PVC 会在第一个 Pod 创建时绑定
    if existingPVC.Status.Phase == corev1.ClaimPending {
        // 返回 bound=true，允许继续创建 VM
        return pvcName, true, nil
    }
}
```

**关键点**:
- 即使 PVC 未绑定，也返回 `bound=true`
- 允许继续创建 VM
- VM Pod 创建时，PVC 会自动绑定

## 4. PVC 状态检查

### 4.1 CheckPVCBound 函数

```go
func CheckPVCBound(ctx context.Context, c client.Client, namespace, name string) (bool, error)
```

**状态判断**:
- `ClaimBound`: 已绑定，返回 `true`
- `ClaimPending`: 未绑定，返回 `false`
- `ClaimLost`: 丢失，返回错误

### 4.2 非阻塞检查

```go
// 不等待，让 controller requeue 来检查状态
logger.Info("PVC created, will check status in next reconcile", "name", pvcName)
return pvcName, false, nil
```

**设计原则**:
- Reconcile 循环应该是非阻塞的
- 通过 requeue 机制等待资源就绪
- 避免长时间阻塞

## 5. Context 取消处理

### 5.1 检查 Context

```go
if ctx.Err() != nil {
    logger.V(1).Info("Context canceled, will retry in next reconcile")
    return pvcName, false, ctx.Err()
}
```

**作用**:
- 检测 Context 是否已取消
- 避免在取消后继续操作
- 返回错误以便 Controller 处理

## 6. 面试要点

### 6.1 为什么 PVC 创建后不等待绑定？

**答案**:
- Reconcile 循环应该是非阻塞的
- 通过 requeue 机制在下次循环检查状态
- 避免长时间阻塞 Controller

### 6.2 WaitForFirstConsumer 模式的作用？

**答案**:
- 延迟绑定，直到第一个 Pod 使用
- 允许 StorageClass 根据 Pod 的节点选择器选择节点
- 适合需要节点亲和性的场景

### 6.3 如何处理 Context 取消？

**答案**:
- 在关键操作前检查 `ctx.Err()`
- 如果已取消，返回错误
- Controller 会在下次循环重试

