# 实时迁移（Live Migration）功能

## 1. 功能概述

### 1.1 实时迁移
在不中断服务的情况下，将运行中的 VM 从一个节点迁移到另一个节点。

**使用场景**:
- 节点维护（无停机维护）
- 负载均衡（分散 VM 到不同节点）
- 故障预防（从问题节点迁移）
- 资源优化（重新分配资源）

### 1.2 迁移类型

#### 实时迁移（Live Migration）
- VM 继续运行，迁移过程中服务不中断
- 需要共享存储（如 Longhorn、Ceph）
- 迁移时间取决于内存大小和网络带宽

#### 非实时迁移（Cold Migration）
- 停止 VM 后迁移
- 所有存储都支持
- 服务会中断

## 2. 当前实现状态

### 2.1 已实现
- ❌ 无迁移功能

### 2.2 待实现
- ❌ **实时迁移**: 实现实时迁移功能
- ❌ **迁移策略**: 迁移策略配置
- ❌ **迁移监控**: 迁移进度和状态监控
- ❌ **自动迁移**: 基于条件的自动迁移

## 3. 技术实现

### 3.1 KubeVirt 支持

KubeVirt 原生支持实时迁移，通过 VirtualMachineInstanceMigration API：

```yaml
apiVersion: kubevirt.io/v1
kind: VirtualMachineInstanceMigration
metadata:
  name: vm-migration
spec:
  vmiName: my-vm
```

### 3.2 实现方案

```go
// pkg/kubevirt/migration.go

func MigrateVM(ctx context.Context, c client.Client, vmName, namespace string, options MigrationOptions) error {
    migration := &kubevirtv1.VirtualMachineInstanceMigration{
        ObjectMeta: metav1.ObjectMeta{
            Name:      fmt.Sprintf("migration-%s-%d", vmName, time.Now().Unix()),
            Namespace: namespace,
        },
        Spec: kubevirtv1.VirtualMachineInstanceMigrationSpec{
            VMIName: vmName,
        },
    }
    
    // 设置迁移选项
    if options.AllowAutoConverge != nil {
        migration.Spec.AllowAutoConverge = options.AllowAutoConverge
    }
    
    if options.AllowPostCopy != nil {
        migration.Spec.AllowPostCopy = options.AllowPostCopy
    }
    
    if options.CompletionTimeoutPerGiB != nil {
        migration.Spec.CompletionTimeoutPerGiB = options.CompletionTimeoutPerGiB
    }
    
    return c.Create(ctx, migration)
}

type MigrationOptions struct {
    // AllowAutoConverge 允许自动收敛（降低迁移速度以完成迁移）
    // +optional
    AllowAutoConverge *bool `json:"allowAutoConverge,omitempty"`
    
    // AllowPostCopy 允许后复制（先迁移，后同步剩余数据）
    // +optional
    AllowPostCopy *bool `json:"allowPostCopy,omitempty"`
    
    // CompletionTimeoutPerGiB 每 GiB 内存的超时时间（秒）
    // +optional
    CompletionTimeoutPerGiB *int64 `json:"completionTimeoutPerGiB,omitempty"`
}
```

### 3.3 Controller 实现

```go
// internal/controller/wukong_controller.go

func (r *WukongReconciler) reconcileMigration(ctx context.Context, vmp *vmv1alpha1.Wukong) error {
    if vmp.Spec.Migration == nil || vmp.Spec.Migration.TargetNode == "" {
        return nil
    }
    
    logger := log.FromContext(ctx)
    vmName := fmt.Sprintf("%s-vm", vmp.Name)
    
    // 检查是否正在迁移
    if vmp.Status.MigrationStatus != nil && 
       vmp.Status.MigrationStatus.Phase == "Migrating" {
        // 监控迁移进度
        return r.monitorMigration(ctx, vmName, vmp)
    }
    
    // 执行迁移
    logger.Info("Starting VM migration", "vm", vmName, "targetNode", vmp.Spec.Migration.TargetNode)
    
    options := kubevirt.MigrationOptions{
        AllowAutoConverge: vmp.Spec.Migration.AllowAutoConverge,
        AllowPostCopy:     vmp.Spec.Migration.AllowPostCopy,
        CompletionTimeoutPerGiB: vmp.Spec.Migration.CompletionTimeoutPerGiB,
    }
    
    if err := kubevirt.MigrateVM(ctx, r.Client, vmName, vmp.Namespace, options); err != nil {
        return err
    }
    
    // 更新状态
    vmp.Status.MigrationStatus = &vmv1alpha1.MigrationStatus{
        Phase:      "Migrating",
        TargetNode: vmp.Spec.Migration.TargetNode,
        StartedAt:  metav1.Now(),
    }
    r.Status().Update(ctx, vmp)
    
    // 清除迁移配置（避免重复迁移）
    vmp.Spec.Migration = nil
    return r.Update(ctx, vmp)
}

func (r *WukongReconciler) monitorMigration(ctx context.Context, vmName string, vmp *vmv1alpha1.Wukong) error {
    // 查询迁移状态
    migrations := &kubevirtv1.VirtualMachineInstanceMigrationList{}
    if err := r.List(ctx, migrations, client.InNamespace(vmp.Namespace)); err != nil {
        return err
    }
    
    // 查找最新的迁移
    var latestMigration *kubevirtv1.VirtualMachineInstanceMigration
    for i := range migrations.Items {
        if migrations.Items[i].Spec.VMIName == vmName {
            if latestMigration == nil || 
               migrations.Items[i].CreationTimestamp.After(latestMigration.CreationTimestamp.Time) {
                latestMigration = &migrations.Items[i]
            }
        }
    }
    
    if latestMigration == nil {
        return nil
    }
    
    // 更新迁移状态
    vmp.Status.MigrationStatus.Phase = string(latestMigration.Status.Phase)
    vmp.Status.MigrationStatus.Progress = latestMigration.Status.MigrationState.Progress
    
    if latestMigration.Status.Phase == kubevirtv1.MigrationSucceeded {
        vmp.Status.MigrationStatus.CompletedAt = metav1.Now()
        vmp.Status.MigrationStatus = nil  // 清除迁移状态
    } else if latestMigration.Status.Phase == kubevirtv1.MigrationFailed {
        vmp.Status.MigrationStatus.Message = latestMigration.Status.MigrationState.FailureReason
        vmp.Status.MigrationStatus = nil
    }
    
    return r.Status().Update(ctx, vmp)
}
```

## 4. API 设计

### 4.1 WukongSpec 扩展

```go
// api/v1alpha1/wukong_types.go

type WukongSpec struct {
    // ... 现有字段 ...
    
    // Migration 迁移配置（可选）
    // +optional
    Migration *MigrationSpec `json:"migration,omitempty"`
}

type MigrationSpec struct {
    // TargetNode 目标节点名称
    TargetNode string `json:"targetNode"`
    
    // AllowAutoConverge 允许自动收敛
    // +optional
    AllowAutoConverge *bool `json:"allowAutoConverge,omitempty"`
    
    // AllowPostCopy 允许后复制
    // +optional
    AllowPostCopy *bool `json:"allowPostCopy,omitempty"`
    
    // CompletionTimeoutPerGiB 每 GiB 内存的超时时间（秒）
    // +optional
    CompletionTimeoutPerGiB *int64 `json:"completionTimeoutPerGiB,omitempty"`
}
```

### 4.2 Status 扩展

```go
// api/v1alpha1/wukong_types.go

type WukongStatus struct {
    // ... 现有字段 ...
    
    // MigrationStatus 迁移状态
    // +optional
    MigrationStatus *MigrationStatus `json:"migrationStatus,omitempty"`
}

type MigrationStatus struct {
    // Phase 迁移阶段: Migrating, Succeeded, Failed
    Phase string `json:"phase"`
    
    // TargetNode 目标节点
    TargetNode string `json:"targetNode"`
    
    // Progress 迁移进度（0-100%）
    // +optional
    Progress string `json:"progress,omitempty"`
    
    // StartedAt 开始时间
    StartedAt metav1.Time `json:"startedAt"`
    
    // CompletedAt 完成时间
    // +optional
    CompletedAt *metav1.Time `json:"completedAt,omitempty"`
    
    // Message 状态消息
    // +optional
    Message string `json:"message,omitempty"`
}
```

### 4.3 迁移策略

```go
// api/v1alpha1/wukong_types.go

type WukongSpec struct {
    // ... 现有字段 ...
    
    // MigrationPolicy 迁移策略（可选）
    // +optional
    MigrationPolicy *MigrationPolicySpec `json:"migrationPolicy,omitempty"`
}

type MigrationPolicySpec struct {
    // Enabled 是否启用自动迁移
    Enabled bool `json:"enabled"`
    
    // TriggerConditions 触发条件
    // +optional
    TriggerConditions []MigrationTriggerCondition `json:"triggerConditions,omitempty"`
    
    // TargetNodeSelector 目标节点选择器
    // +optional
    TargetNodeSelector *metav1.LabelSelector `json:"targetNodeSelector,omitempty"`
}

type MigrationTriggerCondition struct {
    // Type 触发类型: nodeMaintenance, nodeFailure, resourcePressure
    Type string `json:"type"`
    
    // Threshold 阈值（用于 resourcePressure）
    // +optional
    Threshold string `json:"threshold,omitempty"`
}
```

## 5. 使用示例

### 5.1 手动迁移
```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: my-vm
spec:
  migration:
    targetNode: node-2
    allowAutoConverge: true
    completionTimeoutPerGiB: 800
```

### 5.2 自动迁移策略
```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: auto-migrate-vm
spec:
  migrationPolicy:
    enabled: true
    triggerConditions:
    - type: nodeMaintenance
    - type: resourcePressure
      threshold: "80%"
    targetNodeSelector:
      matchLabels:
        node-type: compute
```

### 5.3 后复制迁移
```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: postcopy-vm
spec:
  migration:
    targetNode: node-3
    allowPostCopy: true  # 启用后复制，加快迁移速度
```

## 6. 迁移流程

```
用户触发迁移
    ↓
创建 VirtualMachineInstanceMigration
    ↓
KubeVirt 开始迁移：
  1. 预复制阶段（复制内存页面）
  2. 迭代复制（复制变更的页面）
  3. 切换阶段（切换到目标节点）
  4. 完成迁移
    ↓
更新 VM 状态
    ↓
迁移完成
```

## 7. 注意事项

### 7.1 存储要求
- 需要共享存储（Longhorn、Ceph 等）
- 本地存储不支持实时迁移
- 确保存储可访问

### 7.2 网络要求
- 源节点和目标节点需要网络连通
- 需要足够的网络带宽
- 考虑网络延迟

### 7.3 性能影响
- 迁移过程可能影响 VM 性能
- 大内存 VM 迁移耗时较长
- 需要监控迁移进度

### 7.4 迁移限制
- 某些配置可能不支持迁移
- 需要检查迁移兼容性
- 提供迁移前验证

## 8. 面试要点

### 8.1 实时迁移的工作原理？

**答案**:
- 预复制阶段：复制内存页面到目标节点
- 迭代复制：持续复制变更的页面
- 切换阶段：短暂暂停，切换到目标节点
- 完成：清理源节点资源

### 8.2 实时迁移需要什么条件？

**答案**:
- 共享存储（不能是本地存储）
- 网络连通性
- 足够的网络带宽
- 目标节点有足够资源

### 8.3 如何优化迁移性能？

**答案**:
- 使用后复制模式（AllowPostCopy）
- 增加网络带宽
- 使用自动收敛（AllowAutoConverge）
- 在低峰期执行迁移

