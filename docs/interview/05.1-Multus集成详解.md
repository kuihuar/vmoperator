# Multus 集成详解

## 1. ReconcileNetworks 函数

### 1.1 函数签名

```go
func ReconcileNetworks(ctx context.Context, c client.Client, vmp *vmv1alpha1.Wukong) ([]vmv1alpha1.NetworkStatus, error)
```

**功能**: 为每个 NetworkConfig 创建或查找 NetworkAttachmentDefinition

### 1.2 处理流程

```go
func ReconcileNetworks(ctx context.Context, c client.Client, vmp *vmv1alpha1.Wukong) ([]vmv1alpha1.NetworkStatus, error) {
    statuses := make([]vmv1alpha1.NetworkStatus, 0, len(vmp.Spec.Networks))
    
    for _, netCfg := range vmp.Spec.Networks {
        // 1. 确定 NAD 名称
        nadName := netCfg.NADName
        if nadName == "" {
            nadName = fmt.Sprintf("%s-%s-nad", vmp.Name, netCfg.Name)
        }
        
        // 2. 检查 NAD 是否存在
        nad := &unstructured.Unstructured{}
        // ... 设置 GVK
        
        err := c.Get(ctx, key, nad)
        if err != nil {
            if errors.IsNotFound(err) && netCfg.NADName == "" {
                // 3. 创建新的 NAD
                // ...
            }
        }
        
        // 4. 添加到状态列表
        statuses = append(statuses, vmv1alpha1.NetworkStatus{
            Name:    netCfg.Name,
            NADName: nadName,
        })
    }
    
    return statuses, nil
}
```

## 2. NetworkAttachmentDefinition 创建

### 2.1 检查 Multus CRD

```go
// 检查 Multus CRD 是否存在
crdExists, crdErr := checkMultusCRDExists(ctx, c)
if !crdExists {
    // Multus 未安装，使用默认 Pod 网络
    logger.Info("Multus CNI not installed, using default Pod network")
    return statuses, nil
}
```

### 2.2 构建 CNI 配置

```go
configStr, cfgErr := buildCNIConfig(&netCfg)
if cfgErr != nil {
    return nil, cfgErr
}
```

### 2.3 创建 NAD 对象

```go
nad := &unstructured.Unstructured{}
nad.SetGroupVersionKind(schema.GroupVersionKind{
    Group:   "k8s.cni.cncf.io",
    Version: "v1",
    Kind:    "NetworkAttachmentDefinition",
})

nad.SetName(nadName)
nad.SetNamespace(vmp.Namespace)

// 设置 spec.config
unstructured.SetNestedField(nad.Object, map[string]interface{}{
    "config": configStr,
}, "spec")

// 创建 NAD
if err := c.Create(ctx, nad); err != nil {
    return nil, err
}
```

## 3. CNI 配置构建

### 3.1 buildCNIConfig 函数

```go
func buildCNIConfig(netCfg *vmv1alpha1.NetworkConfig) (string, error) {
    cfg := baseConfig{
        CNIVersion: "0.3.1",
        Type:       netCfg.Type,
    }
    
    // 处理 bridge/ovs 类型
    if netCfg.Type == "bridge" || netCfg.Type == "ovs" {
        if netCfg.BridgeName != "" {
            cfg.Bridge = netCfg.BridgeName
        } else {
            cfg.Bridge = fmt.Sprintf("br-%s", netCfg.Name)
        }
        if netCfg.VLANID != nil {
            cfg.VLAN = netCfg.VLANID
        }
    }
    
    // 处理 IPAM
    if netCfg.IPConfig != nil {
        if netCfg.IPConfig.Mode == "dhcp" {
            cfg.IPAM = map[string]interface{}{
                "type": "dhcp",
            }
        } else if netCfg.IPConfig.Mode == "static" {
            cfg.IPAM = map[string]interface{}{
                "type": "static",
                "addresses": []map[string]string{
                    {"address": *netCfg.IPConfig.Address},
                },
            }
            if netCfg.IPConfig.Gateway != nil {
                cfg.IPAM["routes"] = []map[string]string{
                    {"dst": "0.0.0.0/0", "gw": *netCfg.IPConfig.Gateway},
                }
            }
        }
    }
    
    return json.Marshal(cfg)
}
```

### 3.2 生成的 CNI 配置示例

#### Bridge 类型 (Static IP)

```json
{
  "cniVersion": "0.3.1",
  "type": "bridge",
  "bridge": "br-mgmt",
  "vlan": 100,
  "ipam": {
    "type": "static",
    "addresses": [
      {"address": "192.168.100.10/24"}
    ],
    "routes": [
      {"dst": "0.0.0.0/0", "gw": "192.168.100.1"}
    ]
  }
}
```

#### Bridge 类型 (DHCP)

```json
{
  "cniVersion": "0.3.1",
  "type": "bridge",
  "bridge": "br-data",
  "ipam": {
    "type": "dhcp"
  }
}
```

## 4. KubeVirt 网络集成

### 4.1 构建网络列表

```go
func buildNetworks(networks []vmv1alpha1.NetworkStatus) []kubevirtv1.Network {
    netList := make([]kubevirtv1.Network, 0, len(networks)+1)
    
    // 默认网络（Pod 网络）
    netList = append(netList, kubevirtv1.Network{
        Name: "default",
        NetworkSource: kubevirtv1.NetworkSource{
            Pod: &kubevirtv1.PodNetwork{},
        },
    })
    
    // Multus 网络
    for _, net := range networks {
        if net.NADName != "" {
            netList = append(netList, kubevirtv1.Network{
                Name: net.NADName,
                NetworkSource: kubevirtv1.NetworkSource{
                    Multus: &kubevirtv1.MultusNetwork{
                        NetworkName: net.NADName,
                    },
                },
            })
        }
    }
    
    return netList
}
```

### 4.2 构建网络接口

```go
func buildInterfaces(networks []vmv1alpha1.NetworkStatus) []kubevirtv1.Interface {
    interfaceList := make([]kubevirtv1.Interface, 0, len(networks)+1)
    
    // 默认网络接口（Pod 网络）
    interfaceList = append(interfaceList, kubevirtv1.Interface{
        Name: "default",
        InterfaceBindingMethod: kubevirtv1.InterfaceBindingMethod{
            Masquerade: &kubevirtv1.InterfaceMasquerade{},
        },
    })
    
    // Multus 网络接口
    for _, net := range networks {
        if net.NADName != "" {
            interfaceList = append(interfaceList, kubevirtv1.Interface{
                Name: net.NADName,
                InterfaceBindingMethod: kubevirtv1.InterfaceBindingMethod{
                    Bridge: &kubevirtv1.InterfaceBridge{},
                },
            })
        }
    }
    
    return interfaceList
}
```

### 4.3 Multus 注解

```go
func buildNetworkAnnotations(networks []vmv1alpha1.NetworkStatus) map[string]string {
    annotations := make(map[string]string)
    netList := make([]map[string]string, 0, len(networks))
    
    for i, net := range networks {
        if net.NADName != "" {
            netList = append(netList, map[string]string{
                "name":      net.NADName,
                "interface": fmt.Sprintf("net%d", i+1),
            })
        }
    }
    
    if len(netList) > 0 {
        netJSON, _ := json.Marshal(netList)
        annotations["k8s.v1.cni.cncf.io/networks"] = string(netJSON)
    }
    
    return annotations
}
```

## 5. 错误处理

### 5.1 Multus 未安装

```go
if !crdExists {
    logger.Info("Multus CNI not installed, using default Pod network")
    statuses = append(statuses, vmv1alpha1.NetworkStatus{
        Name: netCfg.Name,
        // 不设置 NADName，表示使用默认网络
    })
    continue
}
```

### 5.2 NAD 创建失败

```go
if err := c.Create(ctx, nad); err != nil {
    logger.Error(err, "failed to create NetworkAttachmentDefinition")
    return nil, err
}
```

## 6. 面试要点

### 6.1 为什么使用 Unstructured？

**答案**:
- NetworkAttachmentDefinition 是 CRD，不是 Kubernetes 核心资源
- 避免引入额外的依赖
- 使用 Unstructured 更灵活

### 6.2 CNI 配置的构建逻辑？

**答案**:
- 根据网络类型（bridge/macvlan/sriov）构建不同的配置
- 支持 VLAN、静态 IP、DHCP 等配置
- 最终序列化为 JSON 字符串存储在 NAD 的 spec.config 中

### 6.3 默认网络的作用？

**答案**:
- 每个 VM 都有一个默认的 Pod 网络
- 用于与 Kubernetes 集群通信
- Multus 网络是额外的网络接口

