# CDI 集成详解

## 1. DataVolume 概述

DataVolume 是 CDI (Containerized Data Importer) 的 CRD，用于从各种源导入数据到 PVC。

### 1.1 使用场景

- **从容器镜像创建磁盘**: 从容器镜像仓库拉取操作系统镜像
- **从 HTTP 源下载**: 从 HTTP/HTTPS URL 下载镜像文件
- **从本地文件导入**: 从本地文件系统导入数据

### 1.2 与 PVC 的区别

| 特性 | PVC | DataVolume |
|------|-----|------------|
| 创建速度 | 快速 | 较慢（需要导入数据） |
| 磁盘内容 | 空 | 包含数据 |
| 使用场景 | 空磁盘 | 预装操作系统的磁盘 |

## 2. ReconcileDataVolume 函数

### 2.1 函数签名

```go
func ReconcileDataVolume(ctx context.Context, c client.Client, disk vmv1alpha1.DiskConfig, namespace, vmName string) (string, bool, error)
```

**返回值**:
- `string`: PVC 名称（DataVolume 创建的 PVC）
- `bool`: 是否已就绪
- `error`: 错误信息

### 2.2 处理流程

```go
func ReconcileDataVolume(ctx context.Context, c client.Client, disk vmv1alpha1.DiskConfig, namespace, vmName string) (string, bool, error) {
    // 1. 生成 DataVolume 名称
    dvName := fmt.Sprintf("%s-%s", vmName, disk.Name)
    pvcName := dvName // DataVolume 创建的 PVC 名称与 DataVolume 名称相同
    
    // 2. 根据 image URL 类型选择不同的 source
    // 3. 构建 DataVolume spec
    // 4. 创建或获取现有的 DataVolume
    // 5. 检查状态
}
```

## 3. 镜像源类型

### 3.1 HTTP/HTTPS 源

```go
if strings.HasPrefix(imageURL, "http://") || strings.HasPrefix(imageURL, "https://") {
    source = map[string]interface{}{
        "http": map[string]interface{}{
            "url": imageURL,
        },
    }
}
```

**使用场景**: 从 HTTP 服务器下载镜像文件

### 3.2 Registry 源

```go
if strings.HasPrefix(imageURL, "docker://") {
    registryURL := strings.TrimPrefix(imageURL, "docker://")
    source = map[string]interface{}{
        "registry": map[string]interface{}{
            "url":        registryURL,
            "pullMethod": "pod",
        },
    }
}
```

**使用场景**: 从容器镜像仓库拉取镜像

**pullMethod**:
- `pod`: 在 Pod 中拉取（推荐，更通用）
- `node`: 在节点上拉取（需要节点配置）

### 3.3 默认处理

```go
// 默认当作 registry URL（兼容旧格式）
source = map[string]interface{}{
    "registry": map[string]interface{}{
        "url":        imageURL,
        "pullMethod": "pod",
    },
}
```

## 4. DataVolume Spec 构建

### 4.1 Spec 结构

```go
spec := map[string]interface{}{
    "source": source,
    "pvc": map[string]interface{}{
        "accessModes": []interface{}{"ReadWriteOnce"},
        "resources": map[string]interface{}{
            "requests": map[string]interface{}{
                "storage": disk.Size,
            },
        },
        "storageClassName": disk.StorageClassName,
    },
}
```

**关键点**:
- `accessModes` 必须使用 `[]interface{}`，避免 DeepCopy panic
- `source` 根据镜像 URL 类型设置
- `pvc` 定义目标 PVC 的规格

## 5. DataVolume 状态检查

### 5.1 CheckDataVolumeStatus 函数

```go
func CheckDataVolumeStatus(ctx context.Context, c client.Client, namespace, name string) (bool, error)
```

### 5.2 Phase 状态

| Phase | 说明 | 返回值 |
|-------|------|--------|
| `Succeeded` | 导入成功 | `true` |
| `Failed` / `Error` | 导入失败 | `error` |
| `WaitForFirstConsumer` | 等待第一个消费者 | 根据 StorageClass 判断 |
| `Pending` / `ImportScheduled` / `ImportInProgress` | 进行中 | `false` |

### 5.3 WaitForFirstConsumer 处理

```go
if phase == "WaitForFirstConsumer" {
    // 检查 StorageClass 的 volumeBindingMode
    if sc.VolumeBindingMode != nil && *sc.VolumeBindingMode == storagev1.VolumeBindingWaitForFirstConsumer {
        // 返回 true，允许继续创建 VM
        return true, nil
    }
    // 否则继续等待
    return false, nil
}
```

## 6. DataVolume 创建流程

### 6.1 创建步骤

```
1. 用户指定 disk.image
   ↓
2. Controller 调用 ReconcileDataVolume()
   ↓
3. 根据 image URL 类型选择 source
   ↓
4. 构建 DataVolume spec
   ↓
5. 创建 DataVolume
   ↓
6. CDI 创建 Importer Pod
   ↓
7. Importer Pod 导入数据
   ↓
8. DataVolume 创建 PVC
   ↓
9. Phase 变为 Succeeded
```

### 6.2 Importer Pod

CDI 会自动创建 Importer Pod 来执行数据导入：
- Pod 名称: `importer-{datavolume-name}`
- 功能: 从源下载/拉取数据并写入 PVC
- 生命周期: 导入完成后自动删除

## 7. 错误处理

### 7.1 导入失败

```go
if phase == "Failed" || phase == "Error" {
    return false, fmt.Errorf("DataVolume %s/%s is in %s state", namespace, name, phase)
}
```

### 7.2 Context 取消

```go
if ctx.Err() != nil {
    logger.V(1).Info("Context canceled, will retry in next reconcile")
    return false, ctx.Err()
}
```

## 8. 使用示例

### 8.1 从容器镜像创建

```yaml
disks:
  - name: system
    size: 80Gi
    storageClassName: longhorn
    image: quay.io/containerdisks/ubuntu:22.04
```

### 8.2 从 HTTP 源下载

```yaml
disks:
  - name: system
    size: 80Gi
    storageClassName: longhorn
    image: https://example.com/ubuntu-22.04.qcow2
```

### 8.3 使用 docker:// 前缀

```yaml
disks:
  - name: system
    size: 80Gi
    storageClassName: longhorn
    image: docker://quay.io/containerdisks/ubuntu:22.04
```

## 9. 面试要点

### 9.1 DataVolume 和 PVC 的区别？

**答案**:
- **DataVolume**: 从源导入数据到 PVC，包含数据
- **PVC**: 直接创建空磁盘，不包含数据
- 选择依据：是否需要预装操作系统

### 9.2 DataVolume 的导入过程？

**答案**:
1. 创建 DataVolume
2. CDI 创建 Importer Pod
3. Importer Pod 从源下载/拉取数据
4. 数据写入 PVC
5. Phase 变为 Succeeded

### 9.3 如何判断 DataVolume 是否就绪？

**答案**:
- 检查 `status.phase` 字段
- `Succeeded` 表示就绪
- 同时检查对应的 PVC 是否已绑定

### 9.4 为什么使用 Unstructured？

**答案**:
- DataVolume 是 CDI 的 CRD，不是 Kubernetes 核心资源
- 避免引入额外的依赖
- 使用 Unstructured 更灵活

