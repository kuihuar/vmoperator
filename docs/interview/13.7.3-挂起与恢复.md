# 挂起与恢复功能

## 1. 功能概述

### 1.1 挂起功能
暂停 VM 运行，将状态保存到内存或磁盘，可以快速恢复。

**使用场景**:
- 临时暂停 VM（节省 CPU 资源）
- 快速保存当前状态
- 维护前暂停
- 资源紧张时暂停非关键 VM

### 1.2 恢复功能
从挂起状态恢复 VM，继续之前的运行状态。

**使用场景**:
- 恢复挂起的 VM
- 快速恢复服务
- 资源充足时恢复

## 2. 当前实现状态

### 2.1 已实现
- ❌ 无挂起/恢复功能

### 2.2 待实现
- ❌ 挂起 VM
- ❌ 恢复 VM
- ❌ 挂起状态管理
- ❌ 挂起数据持久化

## 3. 技术实现

### 3.1 KubeVirt 支持

KubeVirt 通过 VirtualMachineInstance 的 `evictionStrategy` 和迁移功能实现挂起：

```yaml
apiVersion: kubevirt.io/v1
kind: VirtualMachineInstance
spec:
  evictionStrategy: LiveMigrate  # 支持实时迁移
```

### 3.2 实现方案

#### 方案一：使用 VMI 暂停（推荐）
```go
// pkg/kubevirt/lifecycle.go

func SuspendVM(ctx context.Context, c client.Client, vmName, namespace string) error {
    // 1. 获取 VMI
    vmi := &kubevirtv1.VirtualMachineInstance{}
    key := client.ObjectKey{Name: vmName, Namespace: namespace}
    if err := c.Get(ctx, key, vmi); err != nil {
        return fmt.Errorf("VMI not found: %w", err)
    }
    
    // 2. 检查 VMI 状态
    if vmi.Status.Phase != kubevirtv1.Running {
        return fmt.Errorf("VMI is not running (phase: %s)", vmi.Status.Phase)
    }
    
    // 3. 添加暂停注解
    if vmi.Annotations == nil {
        vmi.Annotations = make(map[string]string)
    }
    vmi.Annotations["kubevirt.io/pause"] = "true"
    
    return c.Update(ctx, vmi)
}

func ResumeVM(ctx context.Context, c client.Client, vmName, namespace string) error {
    // 1. 获取 VMI
    vmi := &kubevirtv1.VirtualMachineInstance{}
    key := client.ObjectKey{Name: vmName, Namespace: namespace}
    if err := c.Get(ctx, key, vmi); err != nil {
        return fmt.Errorf("VMI not found: %w", err)
    }
    
    // 2. 检查 VMI 状态
    if vmi.Status.Phase != kubevirtv1.Paused {
        return fmt.Errorf("VMI is not paused (phase: %s)", vmi.Status.Phase)
    }
    
    // 3. 移除暂停注解
    if vmi.Annotations != nil {
        delete(vmi.Annotations, "kubevirt.io/pause")
    }
    
    return c.Update(ctx, vmi)
}
```

#### 方案二：使用 VirtualMachine 停止（简单但丢失状态）
```go
// 停止 VM（状态会丢失）
func SuspendVMByStop(ctx context.Context, c client.Client, vmName, namespace string) error {
    vm := &kubevirtv1.VirtualMachine{}
    key := client.ObjectKey{Name: vmName, Namespace: namespace}
    if err := c.Get(ctx, key, vm); err != nil {
        return err
    }
    
    running := false
    vm.Spec.Running = &running
    
    // 添加挂起标记
    if vm.Annotations == nil {
        vm.Annotations = make(map[string]string)
    }
    vm.Annotations["wukong.novasphere.dev/suspended"] = "true"
    
    return c.Update(ctx, vm)
}
```

### 3.3 Controller 实现

```go
// internal/controller/wukong_controller.go

func (r *WukongReconciler) suspendVM(ctx context.Context, vmName string, vmp *vmv1alpha1.Wukong) error {
    logger := log.FromContext(ctx)
    
    // 更新状态为挂起中
    vmp.Status.LifecycleState = &vmv1alpha1.LifecycleState{
        State:       "Suspending",
        LastAction:  "suspend",
        LastActionTime: metav1.Now(),
    }
    r.Status().Update(ctx, vmp)
    
    // 执行挂起
    if err := kubevirt.SuspendVM(ctx, r.Client, vmName, vmp.Namespace); err != nil {
        vmp.Status.LifecycleState.Message = fmt.Sprintf("Suspend failed: %v", err)
        r.Status().Update(ctx, vmp)
        return err
    }
    
    // 等待挂起完成
    if err := r.waitForVMSuspended(ctx, vmName, vmp.Namespace, 60*time.Second); err != nil {
        vmp.Status.LifecycleState.Message = fmt.Sprintf("Suspend timeout: %v", err)
        r.Status().Update(ctx, vmp)
        return err
    }
    
    logger.Info("VM suspended", "vm", vmName)
    
    // 更新状态为已挂起
    vmp.Status.LifecycleState = &vmv1alpha1.LifecycleState{
        State:       "Suspended",
        LastAction:  "suspend",
        LastActionTime: metav1.Now(),
    }
    r.Status().Update(ctx, vmp)
    
    // 清除 lifecycleAction
    vmp.Spec.LifecycleAction = nil
    return r.Update(ctx, vmp)
}

func (r *WukongReconciler) resumeVM(ctx context.Context, vmName string, vmp *vmv1alpha1.Wukong) error {
    logger := log.FromContext(ctx)
    
    // 更新状态为恢复中
    vmp.Status.LifecycleState = &vmv1alpha1.LifecycleState{
        State:       "Resuming",
        LastAction:  "resume",
        LastActionTime: metav1.Now(),
    }
    r.Status().Update(ctx, vmp)
    
    // 执行恢复
    if err := kubevirt.ResumeVM(ctx, r.Client, vmName, vmp.Namespace); err != nil {
        vmp.Status.LifecycleState.Message = fmt.Sprintf("Resume failed: %v", err)
        r.Status().Update(ctx, vmp)
        return err
    }
    
    // 等待恢复完成
    if err := r.waitForVMRunning(ctx, vmName, vmp.Namespace, 120*time.Second); err != nil {
        vmp.Status.LifecycleState.Message = fmt.Sprintf("Resume timeout: %v", err)
        r.Status().Update(ctx, vmp)
        return err
    }
    
    logger.Info("VM resumed", "vm", vmName)
    
    // 更新状态为运行中
    vmp.Status.LifecycleState = &vmv1alpha1.LifecycleState{
        State:       "Running",
        LastAction:  "resume",
        LastActionTime: metav1.Now(),
    }
    r.Status().Update(ctx, vmp)
    
    // 清除 lifecycleAction
    vmp.Spec.LifecycleAction = nil
    return r.Update(ctx, vmp)
}

func (r *WukongReconciler) waitForVMSuspended(ctx context.Context, vmName, namespace string, timeout time.Duration) error {
    deadline := time.Now().Add(timeout)
    ticker := time.NewTicker(2 * time.Second)
    defer ticker.Stop()
    
    for {
        select {
        case <-ctx.Done():
            return ctx.Err()
        case <-ticker.C:
            if time.Now().After(deadline) {
                return fmt.Errorf("timeout waiting for VM to suspend")
            }
            
            vmi := &kubevirtv1.VirtualMachineInstance{}
            key := client.ObjectKey{Name: vmName, Namespace: namespace}
            if err := r.Get(ctx, key, vmi); err != nil {
                if errors.IsNotFound(err) {
                    return fmt.Errorf("VMI not found")
                }
                return err
            }
            
            // 检查 VMI 状态
            if vmi.Status.Phase == kubevirtv1.Paused {
                return nil
            }
        }
    }
}
```

## 4. API 设计

### 4.1 使用示例

#### 挂起 VM
```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: my-vm
spec:
  cpu: 2
  memory: 4Gi
  lifecycleAction:
    action: suspend
```

#### 恢复 VM
```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: my-vm
spec:
  cpu: 2
  memory: 4Gi
  lifecycleAction:
    action: resume
```

## 5. 注意事项

### 5.1 挂起限制
- 需要 KubeVirt 支持暂停功能
- 某些 VM 配置可能不支持挂起
- 挂起状态占用内存资源

### 5.2 数据持久化
- 挂起状态保存在内存中
- 节点重启会丢失挂起状态
- 考虑使用快照作为备份

### 5.3 性能影响
- 挂起/恢复过程需要时间
- 挂起状态占用内存
- 恢复后可能需要重新初始化网络

### 5.4 状态管理
- 跟踪挂起/恢复过程
- 处理挂起失败的情况
- 提供状态查询接口

## 6. 面试要点

### 6.1 挂起和停止的区别？

**答案**:
- **挂起**: 保存运行状态到内存，可以快速恢复，占用内存资源
- **停止**: 完全关闭 VM，释放所有资源，恢复需要重新启动

### 6.2 如何实现挂起状态的持久化？

**答案**:
- 使用存储后端的快照功能
- 在挂起前创建快照
- 恢复时从快照恢复
- 定期清理旧快照

### 6.3 挂起失败如何处理？

**答案**:
- 检查 KubeVirt 版本和配置
- 检查 VM 配置是否支持挂起
- 记录错误日志
- 提供降级方案（如停止 VM）

