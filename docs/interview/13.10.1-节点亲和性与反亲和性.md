# 节点亲和性与反亲和性

## 1. 功能概述

### 1.1 节点亲和性
控制 VM 调度到特定节点，基于节点的标签和属性。

**使用场景**:
- 调度到特定硬件类型（GPU、SSD等）
- 调度到特定区域或可用区
- 调度到特定节点组
- 资源优化调度

### 1.2 节点反亲和性
避免 VM 调度到特定节点。

**使用场景**:
- 避免调度到维护中的节点
- 避免调度到资源不足的节点
- 避免调度到特定节点类型

## 2. 当前实现状态

### 2.1 已实现
- ✅ **NodeSelector**: 通过 `HighAvailability.NodeSelector` 支持简单节点选择
- ✅ **AntiAffinity**: 通过 `HighAvailability.AntiAffinity` 支持（简单布尔值）

### 2.2 待完善
- ⚠️ **完整亲和性**: 支持 required/preferred 亲和性
- ⚠️ **表达式支持**: 支持复杂表达式（In, NotIn, Exists等）
- ⚠️ **反亲和性配置**: 完整的反亲和性配置

## 3. 技术实现

### 3.1 当前实现

```go
// api/v1alpha1/wukong_types.go

type HighAvailabilitySpec struct {
    // NodeSelector 节点选择器（简单键值匹配）
    NodeSelector map[string]string `json:"nodeSelector,omitempty"`
    
    // AntiAffinity 反亲和性（简单布尔值）
    AntiAffinity bool `json:"antiAffinity,omitempty"`
}
```

### 3.2 扩展实现

```go
// api/v1alpha1/wukong_types.go

type WukongSpec struct {
    // ... 现有字段 ...
    
    // Scheduling 调度配置（可选）
    // +optional
    Scheduling *SchedulingSpec `json:"scheduling,omitempty"`
}

type SchedulingSpec struct {
    // NodeAffinity 节点亲和性
    // +optional
    NodeAffinity *NodeAffinitySpec `json:"nodeAffinity,omitempty"`
    
    // NodeAntiAffinity 节点反亲和性
    // +optional
    NodeAntiAffinity *NodeAntiAffinitySpec `json:"nodeAntiAffinity,omitempty"`
}

type NodeAffinitySpec struct {
    // Required 必须满足的节点选择条件
    // +optional
    Required []NodeSelectorTermSpec `json:"required,omitempty"`
    
    // Preferred 优先满足的节点选择条件
    // +optional
    Preferred []PreferredSchedulingTermSpec `json:"preferred,omitempty"`
}

type NodeSelectorTermSpec struct {
    // MatchExpressions 匹配表达式列表
    // +optional
    MatchExpressions []NodeSelectorRequirementSpec `json:"matchExpressions,omitempty"`
    
    // MatchFields 匹配字段列表
    // +optional
    MatchFields []NodeSelectorRequirementSpec `json:"matchFields,omitempty"`
}

type NodeSelectorRequirementSpec struct {
    // Key 节点标签或字段的键
    Key string `json:"key"`
    
    // Operator 操作符: In, NotIn, Exists, DoesNotExist, Gt, Lt
    Operator string `json:"operator"`
    
    // Values 值列表（某些操作符需要）
    // +optional
    Values []string `json:"values,omitempty"`
}

type PreferredSchedulingTermSpec struct {
    // Weight 权重（1-100）
    Weight int32 `json:"weight"`
    
    // Preference 节点选择条件
    Preference NodeSelectorTermSpec `json:"preference"`
}
```

### 3.3 Controller 实现

```go
// pkg/kubevirt/scheduling.go

func buildAffinity(vmp *vmv1alpha1.Wukong) *corev1.Affinity {
    if vmp.Spec.Scheduling == nil {
        return nil
    }
    
    affinity := &corev1.Affinity{}
    
    // 构建节点亲和性
    if vmp.Spec.Scheduling.NodeAffinity != nil {
        affinity.NodeAffinity = buildNodeAffinity(vmp.Spec.Scheduling.NodeAffinity)
    }
    
    // 构建节点反亲和性（通过 Pod 反亲和性实现）
    if vmp.Spec.Scheduling.NodeAntiAffinity != nil {
        // 节点反亲和性通常通过 Pod 反亲和性实现
        // 或者使用节点亲和性排除特定节点
    }
    
    return affinity
}

func buildNodeAffinity(spec *vmv1alpha1.NodeAffinitySpec) *corev1.NodeAffinity {
    nodeAffinity := &corev1.NodeAffinity{}
    
    // Required 条件
    if len(spec.Required) > 0 {
        nodeAffinity.RequiredDuringSchedulingIgnoredDuringExecution = &corev1.NodeSelector{
            NodeSelectorTerms: buildNodeSelectorTerms(spec.Required),
        }
    }
    
    // Preferred 条件
    if len(spec.Preferred) > 0 {
        preferredTerms := make([]corev1.PreferredSchedulingTerm, 0, len(spec.Preferred))
        for _, pref := range spec.Preferred {
            preferredTerms = append(preferredTerms, corev1.PreferredSchedulingTerm{
                Weight:     pref.Weight,
                Preference: buildNodeSelectorTerm(pref.Preference),
            })
        }
        nodeAffinity.PreferredDuringSchedulingIgnoredDuringExecution = preferredTerms
    }
    
    return nodeAffinity
}

func buildNodeSelectorTerms(terms []vmv1alpha1.NodeSelectorTermSpec) []corev1.NodeSelectorTerm {
    result := make([]corev1.NodeSelectorTerm, 0, len(terms))
    for _, term := range terms {
        result = append(result, buildNodeSelectorTerm(term))
    }
    return result
}

func buildNodeSelectorTerm(term vmv1alpha1.NodeSelectorTermSpec) corev1.NodeSelectorTerm {
    nodeTerm := corev1.NodeSelectorTerm{}
    
    if len(term.MatchExpressions) > 0 {
        nodeTerm.MatchExpressions = buildNodeSelectorRequirements(term.MatchExpressions)
    }
    
    if len(term.MatchFields) > 0 {
        nodeTerm.MatchFields = buildNodeSelectorRequirements(term.MatchFields)
    }
    
    return nodeTerm
}

func buildNodeSelectorRequirements(reqs []vmv1alpha1.NodeSelectorRequirementSpec) []corev1.NodeSelectorRequirement {
    result := make([]corev1.NodeSelectorRequirement, 0, len(reqs))
    for _, req := range reqs {
        result = append(result, corev1.NodeSelectorRequirement{
            Key:      req.Key,
            Operator: corev1.NodeSelectorOperator(req.Operator),
            Values:   req.Values,
        })
    }
    return result
}
```

## 4. API 设计

### 4.1 使用示例

#### 基本节点亲和性
```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: gpu-vm
spec:
  cpu: 4
  memory: 8Gi
  scheduling:
    nodeAffinity:
      required:
      - matchExpressions:
        - key: accelerator
          operator: In
          values: [gpu, nvidia]
```

#### 复杂节点亲和性
```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: zone-vm
spec:
  scheduling:
    nodeAffinity:
      required:
      - matchExpressions:
        - key: topology.kubernetes.io/zone
          operator: In
          values: [zone-a, zone-b]
        - key: node-type
          operator: In
          values: [compute]
      preferred:
      - weight: 80
        preference:
          matchExpressions:
          - key: disk-type
            operator: In
            values: [ssd]
```

#### 节点反亲和性
```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: avoid-maintenance-vm
spec:
  scheduling:
    nodeAntiAffinity:
      required:
      - matchExpressions:
        - key: maintenance
          operator: In
          values: [true]
```

## 5. 实现步骤

### 5.1 第一阶段：基础功能
1. 支持 required 节点亲和性
2. 支持 preferred 节点亲和性
3. 支持基本表达式（In, NotIn, Exists）

### 5.2 第二阶段：增强功能
4. 支持复杂表达式（Gt, Lt）
5. 支持节点反亲和性
6. 支持字段匹配（MatchFields）

### 5.3 第三阶段：优化
7. 调度性能优化
8. 调度失败诊断
9. 调度建议

## 6. 注意事项

### 6.1 调度约束
- Required 条件必须满足，否则无法调度
- Preferred 条件尽量满足，但不强制
- 过多的约束可能导致无法调度

### 6.2 表达式操作符
- **In**: 值在列表中
- **NotIn**: 值不在列表中
- **Exists**: 键存在
- **DoesNotExist**: 键不存在
- **Gt**: 值大于（数值比较）
- **Lt**: 值小于（数值比较）

### 6.3 节点标签
- 使用标准节点标签（如 `kubernetes.io/arch`）
- 使用自定义节点标签
- 确保节点标签正确设置

## 7. 面试要点

### 7.1 节点亲和性和节点选择器的区别？

**答案**:
- **节点选择器**: 简单键值匹配，必须满足，不支持复杂表达式
- **节点亲和性**: 支持复杂表达式，支持 required/preferred，更灵活

### 7.2 Required 和 Preferred 的区别？

**答案**:
- **Required**: 必须满足，否则无法调度
- **Preferred**: 尽量满足，但不强制，可以设置权重

### 7.3 如何实现节点反亲和性？

**答案**:
- 使用节点亲和性排除特定节点（NotIn）
- 使用 Pod 反亲和性配合 topologyKey
- 根据具体需求选择合适的方式

