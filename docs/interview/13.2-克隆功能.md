# VM 克隆功能规划

## 1. 功能概述

### 1.1 克隆功能
基于现有 VM 创建新的 VM，复制磁盘数据。

**使用场景**:
- 快速部署相同配置的 VM
- 创建测试环境
- 批量部署相同系统
- 从模板创建 VM

### 1.2 克隆类型

#### 完整克隆（Full Clone）
- 完全复制源 VM 的所有磁盘数据
- 新 VM 独立于源 VM
- 适用于生产环境

#### 链接克隆（Linked Clone）
- 基于快照创建，共享基础数据
- 节省存储空间
- 适用于开发/测试环境

## 2. 当前实现状态

### 2.1 已实现
- ❌ 无克隆功能

### 2.2 待实现
- ❌ 基于现有 VM 克隆
- ❌ 基于 PVC 克隆
- ❌ 克隆进度查询
- ❌ 克隆状态管理

## 3. 技术实现

### 3.1 KubeVirt 原生支持

KubeVirt 提供 `VirtualMachineClone` API：

```yaml
apiVersion: clone.kubevirt.io/v1alpha1
kind: VirtualMachineClone
metadata:
  name: clone-vm
spec:
  source:
    apiGroup: kubevirt.io
    kind: VirtualMachine
    name: source-vm
  target:
    apiGroup: kubevirt.io
    kind: VirtualMachine
    name: target-vm
  annotationFilters:
  - "*"
  labelFilters:
  - "*"
```

### 3.2 实现方案

#### 方案一：使用 VirtualMachineClone
```go
// pkg/kubevirt/clone.go
func CloneVirtualMachine(ctx context.Context, c client.Client, sourceVM, targetVM string, namespace string) error {
    clone := &clonev1alpha1.VirtualMachineClone{
        ObjectMeta: metav1.ObjectMeta{
            Name:      fmt.Sprintf("clone-%s", targetVM),
            Namespace:  namespace,
        },
        Spec: clonev1alpha1.VirtualMachineCloneSpec{
            Source: corev1.TypedLocalObjectReference{
                APIGroup: &apiGroup,
                Kind:     "VirtualMachine",
                Name:     sourceVM,
            },
            Target: &corev1.TypedLocalObjectReference{
                APIGroup: &apiGroup,
                Kind:     "VirtualMachine",
                Name:     targetVM,
            },
        },
    }
    return c.Create(ctx, clone)
}
```

#### 方案二：手动克隆（基于 PVC）
```go
// pkg/storage/clone.go
func ClonePVC(ctx context.Context, c client.Client, sourcePVC, targetPVC string, namespace string) error {
    // 1. 获取源 PVC
    source := &corev1.PersistentVolumeClaim{}
    if err := c.Get(ctx, client.ObjectKey{Name: sourcePVC, Namespace: namespace}, source); err != nil {
        return err
    }
    
    // 2. 创建 DataVolume 克隆
    dv := &cdiv1beta1.DataVolume{
        ObjectMeta: metav1.ObjectMeta{
            Name:      targetPVC,
            Namespace:  namespace,
        },
        Spec: cdiv1beta1.DataVolumeSpec{
            Source: &cdiv1beta1.DataVolumeSource{
                PVC: &cdiv1beta1.DataVolumeSourcePVC{
                    Name:      sourcePVC,
                    Namespace:  namespace,
                },
            },
            PVC: &corev1.PersistentVolumeClaimSpec{
                AccessModes: source.Spec.AccessModes,
                Resources:   source.Spec.Resources,
            },
        },
    }
    return c.Create(ctx, dv)
}
```

## 4. API 设计

### 4.1 WukongSpec 扩展

```go
// api/v1alpha1/wukong_types.go

type WukongSpec struct {
    // ... 现有字段 ...
    
    // CloneSource 定义克隆源（可选）
    // +optional
    CloneSource *CloneSourceSpec `json:"cloneSource,omitempty"`
}

type CloneSourceSpec struct {
    // Type 克隆源类型: vm, pvc
    Type string `json:"type"`
    
    // VMName 源 VM 名称（用于 vm 类型）
    // +optional
    VMName string `json:"vmName,omitempty"`
    
    // PVCName 源 PVC 名称（用于 pvc 类型）
    // +optional
    PVCName string `json:"pvcName,omitempty"`
    
    // Namespace 源资源命名空间
    // +optional
    Namespace string `json:"namespace,omitempty"`
    
    // CloneType 克隆类型: full, linked
    // +optional
    CloneType string `json:"cloneType,omitempty"` // 默认 full
}
```

### 4.2 Status 扩展

```go
// api/v1alpha1/wukong_types.go

type WukongStatus struct {
    // ... 现有字段 ...
    
    // CloneStatus 克隆状态
    // +optional
    CloneStatus *CloneStatus `json:"cloneStatus,omitempty"`
}

type CloneStatus struct {
    Phase      string `json:"phase"`      // Pending, Cloning, Succeeded, Failed
    Progress   string `json:"progress"`   // 0-100%
    Message    string `json:"message,omitempty"`
    SourceVM   string `json:"sourceVM,omitempty"`
    SourcePVC  string `json:"sourcePVC,omitempty"`
}
```

## 5. 实现步骤

### 5.1 第一阶段：基础克隆
1. 支持基于现有 VM 克隆
2. 支持基于 PVC 克隆
3. 实现完整克隆（Full Clone）

### 5.2 第二阶段：高级特性
1. 支持链接克隆（Linked Clone）
2. 支持跨命名空间克隆
3. 实现克隆进度查询

### 5.3 第三阶段：优化
1. 克隆性能优化
2. 支持选择性克隆（仅克隆指定磁盘）
3. 支持克隆模板

## 6. 使用示例

### 6.1 基于 VM 克隆
```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: cloned-vm
spec:
  cpu: 2
  memory: 4Gi
  cloneSource:
    type: vm
    vmName: source-vm
    namespace: default
    cloneType: full
  disks:
  - name: system
    size: 20Gi
    # 磁盘将从源 VM 克隆，size 可以不同
```

### 6.2 基于 PVC 克隆
```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: cloned-from-pvc
spec:
  cpu: 2
  memory: 4Gi
  cloneSource:
    type: pvc
    pvcName: source-disk
    namespace: default
  disks:
  - name: system
    size: 20Gi
    # 磁盘将从源 PVC 克隆
```

### 6.3 链接克隆（基于快照）
```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: linked-clone-vm
spec:
  cpu: 2
  memory: 4Gi
  cloneSource:
    type: vm
    vmName: template-vm
    cloneType: linked  # 基于快照的链接克隆
  disks:
  - name: system
    size: 20Gi
```

## 7. Controller 实现

```go
// internal/controller/wukong_controller.go

func (r *WukongReconciler) reconcileClone(ctx context.Context, vmp *vmv1alpha1.Wukong) error {
    if vmp.Spec.CloneSource == nil {
        return nil
    }
    
    logger := log.FromContext(ctx)
    
    switch vmp.Spec.CloneSource.Type {
    case "vm":
        return r.cloneFromVM(ctx, vmp)
    case "pvc":
        return r.cloneFromPVC(ctx, vmp)
    default:
        return fmt.Errorf("unsupported clone source type: %s", vmp.Spec.CloneSource.Type)
    }
}

func (r *WukongReconciler) cloneFromVM(ctx context.Context, vmp *vmv1alpha1.Wukong) error {
    // 1. 检查源 VM 是否存在
    // 2. 创建 VirtualMachineClone
    // 3. 监控克隆进度
    // 4. 更新状态
}

func (r *WukongReconciler) cloneFromPVC(ctx context.Context, vmp *vmv1alpha1.Wukong) error {
    // 1. 检查源 PVC 是否存在
    // 2. 为每个磁盘创建 DataVolume 克隆
    // 3. 监控克隆进度
    // 4. 更新状态
}
```

## 8. 注意事项

### 8.1 性能考虑
- 大磁盘克隆可能耗时较长
- 考虑使用快照加速克隆
- 支持并行克隆多个磁盘

### 8.2 存储空间
- 完整克隆需要双倍存储空间
- 链接克隆节省空间但性能可能受影响
- 需要检查存储配额

### 8.3 数据一致性
- 克隆过程中源 VM 不应修改
- 建议在克隆前停止源 VM
- 支持基于快照的克隆（数据一致性）

## 9. 面试要点

### 9.1 完整克隆和链接克隆的区别？

**答案**:
- **完整克隆**: 完全复制数据，独立存储，性能好，但占用空间大
- **链接克隆**: 基于快照，共享基础数据，节省空间，但性能可能受影响

### 9.2 如何优化克隆性能？

**答案**:
- 使用存储后端的快照功能
- 支持增量克隆
- 并行克隆多个磁盘
- 使用压缩减少传输时间

### 9.3 克隆过程中如何保证数据一致性？

**答案**:
- 在克隆前创建快照
- 基于快照进行克隆
- 支持只读模式克隆
- 记录克隆时间点

