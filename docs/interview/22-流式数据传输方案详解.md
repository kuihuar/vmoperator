# 流式数据传输方案详解

## 1. 概述

流式数据传输用于实时推送数据，支持多种实现方式。

## 2. 流式数据传输方式

### 2.1 Server-Sent Events (SSE)

**特点**：
- ✅ 服务器到客户端的单向流
- ✅ 浏览器原生支持
- ✅ 自动重连
- ✅ 简单易用

**适用场景**：
- 实时状态更新
- 日志流式输出
- 进度通知

### 2.2 WebSocket

**特点**：
- ✅ 双向通信
- ✅ 全双工
- ✅ 低延迟

**适用场景**：
- 控制台交互
- 实时聊天
- 需要客户端交互的场景

### 2.3 gRPC Stream

**特点**：
- ✅ 高性能
- ✅ 强类型
- ✅ 多语言支持

**适用场景**：
- 内部服务调用
- 高性能流式传输
- ❌ 浏览器不支持（需要 gRPC-Web）

## 3. Fiber 流式响应实现

### 3.1 SSE 实现

```go
// internal/handlers/stream.go
package handlers

import (
    "bufio"
    "encoding/json"
    "fmt"
    "time"
    
    "github.com/gofiber/fiber/v2"
)

func StreamWukongStatus(c *fiber.Ctx) error {
    wukongName := c.Params("name")
    
    // 设置 SSE 响应头
    c.Set("Content-Type", "text/event-stream")
    c.Set("Cache-Control", "no-cache")
    c.Set("Connection", "keep-alive")
    c.Set("X-Accel-Buffering", "no") // 禁用 Nginx 缓冲
    
    // 流式发送数据
    return c.Context().SetBodyStreamWriter(func(w *bufio.Writer) {
        ticker := time.NewTicker(1 * time.Second)
        defer ticker.Stop()
        
        // 发送初始连接消息
        fmt.Fprintf(w, "event: connected\ndata: {\"message\":\"connected\"}\n\n")
        w.Flush()
        
        for {
            select {
            case <-ticker.C:
                // 获取 Wukong 状态
                status := getWukongStatus(wukongName)
                
                // 转换为 JSON
                data, _ := json.Marshal(status)
                
                // 发送 SSE 格式数据
                fmt.Fprintf(w, "event: status\ndata: %s\n\n", string(data))
                w.Flush()
                
            case <-c.Context().Done():
                // 客户端断开连接
                fmt.Fprintf(w, "event: closed\ndata: {\"message\":\"connection closed\"}\n\n")
                w.Flush()
                return
            }
        }
    })
}
```

### 3.2 流式 JSON 实现

```go
func StreamWukongList(c *fiber.Ctx) error {
    c.Set("Content-Type", "application/json")
    c.Set("Transfer-Encoding", "chunked")
    
    return c.Context().SetBodyStreamWriter(func(w *bufio.Writer) {
        w.WriteString("{\"wukongs\":[")
        
        wukongs := getWukongs()
        for i, wukong := range wukongs {
            if i > 0 {
                w.WriteString(",")
            }
            
            json, _ := json.Marshal(wukong)
            w.Write(json)
            w.Flush() // 立即刷新，实现流式传输
            
            time.Sleep(100 * time.Millisecond) // 模拟流式传输
        }
        
        w.WriteString("]}")
        w.Flush()
    })
}
```

### 3.3 WebSocket 实现

```go
import (
    "github.com/gofiber/websocket/v2"
)

func SetupWebSocketRoutes(app *fiber.App) {
    app.Get("/ws/wukong/:name", websocket.New(func(c *websocket.Conn) {
        wukongName := c.Params("name")
        
        // 发送欢迎消息
        c.WriteJSON(fiber.Map{
            "type": "connected",
            "message": "Connected to " + wukongName,
        })
        
        // 启动状态推送
        ticker := time.NewTicker(1 * time.Second)
        defer ticker.Stop()
        
        for {
            select {
            case <-ticker.C:
                // 获取状态并推送
                status := getWukongStatus(wukongName)
                c.WriteJSON(fiber.Map{
                    "type": "status",
                    "data": status,
                })
                
            default:
                // 读取客户端消息
                var msg map[string]interface{}
                if err := c.ReadJSON(&msg); err != nil {
                    return
                }
                
                // 处理消息
                handleWebSocketMessage(c, wukongName, msg)
            }
        }
    }))
}
```

## 4. Gin 流式响应实现

### 4.1 Gin 原生支持

**重要**：Gin **原生支持流式响应**，**不需要额外库**！Gin 基于 `net/http`，可以直接使用 `http.Flusher` 接口。

### 4.2 SSE 实现（无需额外库）

```go
// internal/handlers/stream.go
package handlers

import (
    "encoding/json"
    "fmt"
    "net/http"
    "time"
    
    "github.com/gin-gonic/gin"
)

func StreamWukongStatus(c *gin.Context) {
    wukongName := c.Param("name")
    
    // 设置 SSE 响应头
    c.Header("Content-Type", "text/event-stream")
    c.Header("Cache-Control", "no-cache")
    c.Header("Connection", "keep-alive")
    c.Header("X-Accel-Buffering", "no") // 禁用 Nginx 缓冲
    
    // 获取 Flusher（Gin 的 Writer 实现了 http.Flusher）
    w := c.Writer
    flusher, ok := w.(http.Flusher)
    if !ok {
        c.AbortWithStatus(http.StatusInternalServerError)
        return
    }
    
    // 发送初始连接消息
    fmt.Fprintf(w, "event: connected\ndata: {\"message\":\"connected\"}\n\n")
    flusher.Flush()
    
    ticker := time.NewTicker(1 * time.Second)
    defer ticker.Stop()
    
    for {
        select {
        case <-ticker.C:
            // 获取 Wukong 状态
            status := getWukongStatus(wukongName)
            data, _ := json.Marshal(status)
            
            // 发送 SSE 格式数据
            fmt.Fprintf(w, "event: status\ndata: %s\n\n", string(data))
            flusher.Flush() // 立即刷新，实现流式传输
            
        case <-c.Request.Context().Done():
            // 客户端断开连接
            fmt.Fprintf(w, "event: closed\ndata: {\"message\":\"connection closed\"}\n\n")
            flusher.Flush()
            return
        }
    }
}
```

### 4.3 流式 JSON 实现（无需额外库）

```go
func StreamWukongList(c *gin.Context) {
    // 设置响应头
    c.Header("Content-Type", "application/json")
    c.Header("Transfer-Encoding", "chunked")
    
    w := c.Writer
    flusher, ok := w.(http.Flusher)
    if !ok {
        c.AbortWithStatus(http.StatusInternalServerError)
        return
    }
    
    // 开始 JSON 数组
    fmt.Fprint(w, "{\"wukongs\":[")
    flusher.Flush()
    
    wukongs := getWukongs()
    for i, wukong := range wukongs {
        if i > 0 {
            fmt.Fprint(w, ",")
        }
        
        json, _ := json.Marshal(wukong)
        w.Write(json)
        flusher.Flush() // 立即刷新，实现流式传输
        
        time.Sleep(100 * time.Millisecond) // 模拟流式传输
    }
    
    // 结束 JSON 数组
    fmt.Fprint(w, "]}")
    flusher.Flush()
}
```

### 4.4 WebSocket 实现（需要额外库）

**Gin 本身不支持 WebSocket**，需要额外库：

#### 方案 A：使用 gorilla/websocket（推荐）

```bash
go get github.com/gorilla/websocket
```

```go
// internal/handlers/websocket.go
package handlers

import (
    "github.com/gin-gonic/gin"
    "github.com/gorilla/websocket"
)

var upgrader = websocket.Upgrader{
    CheckOrigin: func(r *http.Request) bool {
        return true // 生产环境需要检查 Origin
    },
}

func WukongWebSocket(c *gin.Context) {
    wukongName := c.Param("name")
    
    // 升级 HTTP 连接为 WebSocket
    conn, err := upgrader.Upgrade(c.Writer, c.Request, nil)
    if err != nil {
        c.AbortWithError(http.StatusBadRequest, err)
        return
    }
    defer conn.Close()
    
    // 发送欢迎消息
    conn.WriteJSON(gin.H{
        "type": "connected",
        "message": "Connected to " + wukongName,
    })
    
    // 启动状态推送
    ticker := time.NewTicker(1 * time.Second)
    defer ticker.Stop()
    
    // 消息通道
    messageChan := make(chan []byte, 256)
    
    // 读取客户端消息
    go func() {
        for {
            _, message, err := conn.ReadMessage()
            if err != nil {
                close(messageChan)
                return
            }
            messageChan <- message
        }
    }()
    
    // 主循环
    for {
        select {
        case <-ticker.C:
            // 推送状态更新
            status := getWukongStatus(wukongName)
            conn.WriteJSON(gin.H{
                "type": "status",
                "data": status,
            })
            
        case message, ok := <-messageChan:
            if !ok {
                return
            }
            // 处理客户端消息
            handleWebSocketMessage(conn, wukongName, message)
            
        case <-c.Request.Context().Done():
            return
        }
    }
}
```

#### 方案 B：使用 gin-websocket（第三方封装）

```bash
go get github.com/olahol/melody
```

```go
import (
    "github.com/gin-gonic/gin"
    "github.com/olahol/melody"
)

func SetupWebSocketRoutes(router *gin.Engine) {
    m := melody.New()
    
    router.GET("/ws/wukong/:name", func(c *gin.Context) {
        wukongName := c.Param("name")
        
        m.HandleRequestWithKeys(c.Writer, c.Request, map[string]interface{}{
            "wukongName": wukongName,
        })
    })
    
    m.HandleMessage(func(s *melody.Session, msg []byte) {
        // 处理消息
        wukongName := s.Keys["wukongName"].(string)
        handleMessage(s, wukongName, msg)
    })
    
    m.HandleConnect(func(s *melody.Session) {
        // 连接建立
        wukongName := s.Keys["wukongName"].(string)
        s.Write([]byte("Connected to " + wukongName))
    })
}
```

### 4.5 Gin 流式响应总结

| 功能 | 是否需要额外库 | 说明 |
|------|---------------|------|
| **SSE** | ❌ 不需要 | Gin 原生支持，使用 `http.Flusher` |
| **流式 JSON** | ❌ 不需要 | Gin 原生支持，使用 `http.Flusher` |
| **WebSocket** | ✅ 需要 | 使用 `gorilla/websocket` 或 `melody` |

## 5. Gin vs Fiber 流式支持对比

### 5.1 原生支持对比

| 功能 | Gin | Fiber |
|------|-----|-------|
| **SSE** | ✅ 原生支持 | ✅ 原生支持 |
| **流式 JSON** | ✅ 原生支持 | ✅ 原生支持 |
| **WebSocket** | ❌ 需要库 | ✅ 内置支持 |

### 5.2 实现复杂度

**Gin SSE/流式 JSON**：
```go
// 简单，使用标准库接口
flusher, _ := w.(http.Flusher)
flusher.Flush()
```

**Fiber SSE/流式 JSON**：
```go
// 简单，使用 Fiber API
c.Context().SetBodyStreamWriter(func(w *bufio.Writer) {
    w.Flush()
})
```

**Gin WebSocket**：
```go
// 需要额外库
upgrader.Upgrade(c.Writer, c.Request, nil)
```

**Fiber WebSocket**：
```go
// 内置支持
websocket.New(func(c *websocket.Conn) {})
```

## 6. 推荐方案

### 6.1 如果使用 Gin

- ✅ **SSE/流式 JSON**：直接使用，无需额外库
- ✅ **WebSocket**：使用 `gorilla/websocket`（标准库）

### 6.2 如果使用 Fiber

- ✅ **所有流式功能**：内置支持，无需额外库

### 6.3 选择建议

- **已有 Gin 项目**：继续使用 Gin，SSE/流式 JSON 无需改动，WebSocket 只需添加一个库
- **新项目**：可以考虑 Fiber，内置 WebSocket 支持更方便

## 5. 前端使用示例

### 5.1 SSE 客户端（Web）

```typescript
// web/src/api/sse.ts
export function createSSEConnection(wukongName: string) {
  const eventSource = new EventSource(
    `https://api.novasphere.io/api/v1/wukongs/${wukongName}/stream`
  );
  
  eventSource.addEventListener('status', (event) => {
    const data = JSON.parse(event.data);
    console.log('Status update:', data);
    // 更新 UI
  });
  
  eventSource.addEventListener('connected', (event) => {
    console.log('Connected');
  });
  
  eventSource.onerror = (error) => {
    console.error('SSE error:', error);
  };
  
  return eventSource;
}
```

### 5.2 WebSocket 客户端（Web）

```typescript
// web/src/api/websocket.ts
export function createWebSocketConnection(wukongName: string) {
  const ws = new WebSocket(
    `wss://api.novasphere.io/ws/wukong/${wukongName}`
  );
  
  ws.onmessage = (event) => {
    const data = JSON.parse(event.data);
    console.log('Message:', data);
    // 处理消息
  };
  
  ws.onerror = (error) => {
    console.error('WebSocket error:', error);
  };
  
  ws.onclose = () => {
    console.log('WebSocket closed');
  };
  
  return ws;
}
```

### 5.3 Flutter 流式数据

```dart
// flutter/lib/api/stream.dart
import 'package:stream_transform/stream_transform.dart';

class StreamAPI {
  // SSE 流
  Stream<WukongStatus> streamWukongStatus(String name) async* {
    final response = await http.get(
      Uri.parse('https://api.novasphere.io/api/v1/wukongs/$name/stream'),
      headers: {
        'Accept': 'text/event-stream',
      },
    ).timeout(Duration(seconds: 30));
    
    await for (final line in response.body.split('\n')) {
      if (line.startsWith('data: ')) {
        final json = jsonDecode(line.substring(6));
        yield WukongStatus.fromJson(json);
      }
    }
  }
  
  // WebSocket 流
  Stream<Map<String, dynamic>> webSocketStream(String name) {
    final channel = WebSocketChannel.connect(
      Uri.parse('wss://api.novasphere.io/ws/wukong/$name'),
    );
    
    return channel.stream.map((data) => jsonDecode(data));
  }
}
```

## 6. 性能对比

### 6.1 延迟对比

| 方式 | 延迟 | 适用场景 |
|------|------|---------|
| **SSE** | 低 | 单向推送 |
| **WebSocket** | 极低 | 双向通信 |
| **gRPC Stream** | 极低 | 内部服务 |

### 6.2 资源消耗

| 方式 | 内存 | CPU | 连接数 |
|------|------|-----|--------|
| **SSE** | 低 | 低 | 中等 |
| **WebSocket** | 中 | 中 | 高 |
| **gRPC Stream** | 低 | 低 | 高 |

## 7. Gin 流式响应详细说明

### 7.1 Gin 需要加什么？

**答案**：
- ✅ **SSE 和流式 JSON**：**不需要加任何东西**，Gin 原生支持
- ✅ **WebSocket**：需要添加 `gorilla/websocket` 库

### 7.2 为什么 Gin 原生支持流式？

Gin 基于 Go 标准库 `net/http`，而 `net/http` 的 `ResponseWriter` 接口实现了 `http.Flusher`：

```go
type Flusher interface {
    Flush()
}
```

Gin 的 `c.Writer` 就是 `http.ResponseWriter`，所以可以直接使用：

```go
w := c.Writer
flusher, ok := w.(http.Flusher) // 类型断言
if ok {
    flusher.Flush() // 立即刷新缓冲区
}
```

### 7.3 完整示例

```go
// Gin SSE 完整示例（无需额外库）
package handlers

import (
    "fmt"
    "net/http"
    "time"
    "github.com/gin-gonic/gin"
)

func StreamWukongStatus(c *gin.Context) {
    wukongName := c.Param("name")
    
    // 1. 设置响应头（必须）
    c.Header("Content-Type", "text/event-stream")
    c.Header("Cache-Control", "no-cache")
    c.Header("Connection", "keep-alive")
    c.Header("X-Accel-Buffering", "no") // 禁用 Nginx 缓冲
    
    // 2. 获取 Flusher（Gin 原生支持）
    w := c.Writer
    flusher, ok := w.(http.Flusher)
    if !ok {
        c.AbortWithStatus(http.StatusInternalServerError)
        return
    }
    
    // 3. 流式发送数据
    ticker := time.NewTicker(1 * time.Second)
    defer ticker.Stop()
    
    for {
        select {
        case <-ticker.C:
            status := getWukongStatus(wukongName)
            fmt.Fprintf(w, "data: %s\n\n", status)
            flusher.Flush() // 关键：立即刷新
            
        case <-c.Request.Context().Done():
            return
        }
    }
}
```

### 7.4 WebSocket 需要添加的库

```bash
# 安装 gorilla/websocket
go get github.com/gorilla/websocket
```

```go
import (
    "github.com/gorilla/websocket"
)

var upgrader = websocket.Upgrader{
    CheckOrigin: func(r *http.Request) bool {
        return true
    },
}

func WukongWebSocket(c *gin.Context) {
    // 升级 HTTP 连接为 WebSocket
    conn, err := upgrader.Upgrade(c.Writer, c.Request, nil)
    if err != nil {
        return
    }
    defer conn.Close()
    
    // 使用 WebSocket 连接
    for {
        messageType, message, err := conn.ReadMessage()
        if err != nil {
            break
        }
        
        // 处理消息
        conn.WriteMessage(messageType, message)
    }
}
```

## 8. 选择建议

### 8.1 Web 前端

- **实时状态更新**：SSE（Gin/Fiber 都原生支持）
- **控制台交互**：WebSocket
- **简单通知**：SSE

### 8.2 移动端

- **实时推送**：WebSocket 或 SSE
- **离线支持**：结合本地缓存

### 8.3 内部服务

- **高性能流式传输**：gRPC Stream
- **服务间通信**：gRPC Stream

## 9. 总结

### 9.1 Gin 流式支持

- ✅ **SSE**：原生支持，**不需要额外库**
- ✅ **流式 JSON**：原生支持，**不需要额外库**
- ✅ **WebSocket**：需要 `gorilla/websocket` 库

### 9.2 Fiber 流式支持

- ✅ **SSE**：原生支持
- ✅ **流式 JSON**：原生支持
- ✅ **WebSocket**：内置支持（无需额外库）

### 9.3 选择建议

- **如果使用 Gin**：SSE/流式 JSON 直接使用，WebSocket 只需添加一个库
- **如果使用 Fiber**：所有流式功能都内置，更方便
- **根据项目需求**：选择团队熟悉的框架

