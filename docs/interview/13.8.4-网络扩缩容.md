# 网络扩缩容

## 1. 功能概述

### 1.1 网络扩缩容
在 VM 运行过程中添加或删除网络接口，无需重启 VM。

**使用场景**:
- 运行时添加网络接口
- 移除不需要的网络接口
- 网络配置调整
- 多网络场景管理

### 1.2 网络类型
- **Bridge**: 桥接网络
- **Macvlan**: Macvlan 网络
- **SR-IOV**: SR-IOV 网络
- **OVS**: Open vSwitch 网络

## 2. 当前实现状态

### 2.1 已实现
- ✅ **静态配置**: 创建时配置网络接口
- ✅ **Multus 集成**: 支持多网络接口

### 2.2 待实现
- ❌ **动态添加网络**: 运行时添加网络接口
- ❌ **动态删除网络**: 运行时删除网络接口
- ❌ **网络配置更新**: 更新网络配置
- ❌ **网络状态同步**: 同步网络状态

## 3. 技术实现

### 3.1 KubeVirt 支持

KubeVirt 支持动态添加/删除网络接口，通过修改 VirtualMachineInstance 的 Networks 和 Interfaces。

### 3.2 实现方案

```go
// pkg/network/scaling.go

func AttachNetwork(ctx context.Context, c client.Client, vmName, namespace string, network NetworkConfig) error {
    // 1. 获取 VMI
    vmi := &kubevirtv1.VirtualMachineInstance{}
    key := client.ObjectKey{Name: vmName, Namespace: namespace}
    if err := c.Get(ctx, key, vmi); err != nil {
        return fmt.Errorf("VMI not found: %w", err)
    }
    
    // 2. 检查网络是否已存在
    for _, existingNet := range vmi.Spec.Networks {
        if existingNet.Name == network.Name {
            return fmt.Errorf("network %s already exists", network.Name)
        }
    }
    
    // 3. 创建或获取 NAD（如果需要）
    nadName := network.NADName
    if nadName == "" {
        // 创建新的 NAD
        nad, err := createNAD(ctx, c, network, namespace)
        if err != nil {
            return err
        }
        nadName = nad.Name
    }
    
    // 4. 添加网络到 VMI
    newNetwork := kubevirtv1.Network{
        Name: network.Name,
        NetworkSource: kubevirtv1.NetworkSource{
            Multus: &kubevirtv1.MultusNetwork{
                NetworkName: nadName,
            },
        },
    }
    vmi.Spec.Networks = append(vmi.Spec.Networks, newNetwork)
    
    // 5. 添加接口到 VMI
    newInterface := kubevirtv1.Interface{
        Name: network.Name,
        InterfaceBindingMethod: kubevirtv1.InterfaceBindingMethod{
            Bridge: &kubevirtv1.InterfaceBridge{},
        },
    }
    vmi.Spec.Domain.Devices.Interfaces = append(vmi.Spec.Domain.Devices.Interfaces, newInterface)
    
    // 6. 更新 VMI
    return c.Update(ctx, vmi)
}

func DetachNetwork(ctx context.Context, c client.Client, vmName, namespace, networkName string) error {
    // 1. 获取 VMI
    vmi := &kubevirtv1.VirtualMachineInstance{}
    key := client.ObjectKey{Name: vmName, Namespace: namespace}
    if err := c.Get(ctx, key, vmi); err != nil {
        return fmt.Errorf("VMI not found: %w", err)
    }
    
    // 2. 检查网络是否存在
    networkExists := false
    for _, net := range vmi.Spec.Networks {
        if net.Name == networkName {
            networkExists = true
            break
        }
    }
    if !networkExists {
        return fmt.Errorf("network %s not found", networkName)
    }
    
    // 3. 验证网络未使用（可选）
    if err := verifyNetworkNotInUse(ctx, c, vmi, networkName); err != nil {
        return fmt.Errorf("network is in use: %w", err)
    }
    
    // 4. 从 VMI 中移除网络
    newNetworks := make([]kubevirtv1.Network, 0)
    for _, net := range vmi.Spec.Networks {
        if net.Name != networkName {
            newNetworks = append(newNetworks, net)
        }
    }
    vmi.Spec.Networks = newNetworks
    
    // 5. 从 VMI 中移除接口
    newInterfaces := make([]kubevirtv1.Interface, 0)
    for _, iface := range vmi.Spec.Domain.Devices.Interfaces {
        if iface.Name != networkName {
            newInterfaces = append(newInterfaces, iface)
        }
    }
    vmi.Spec.Domain.Devices.Interfaces = newInterfaces
    
    // 6. 更新 VMI
    return c.Update(ctx, vmi)
}
```

### 3.3 Controller 实现

```go
// internal/controller/wukong_controller.go

func (r *WukongReconciler) reconcileNetworkScaling(ctx context.Context, vmp *vmv1alpha1.Wukong) error {
    logger := log.FromContext(ctx)
    vmName := fmt.Sprintf("%s-vm", vmp.Name)
    
    // 1. 获取当前 VMI（如果运行中）
    vmi := &kubevirtv1.VirtualMachineInstance{}
    key := client.ObjectKey{Name: vmName, Namespace: vmp.Namespace}
    vmiExists := r.Get(ctx, key, vmi) == nil && vmi.Status.Phase == kubevirtv1.Running
    
    // 2. 检查需要添加的网络
    specNetworks := make(map[string]bool)
    for _, network := range vmp.Spec.Networks {
        specNetworks[network.Name] = true
        
        // 检查网络是否已配置
        var netStatus *vmv1alpha1.NetworkStatus
        for i := range vmp.Status.Networks {
            if vmp.Status.Networks[i].Name == network.Name {
                netStatus = &vmp.Status.Networks[i]
                break
            }
        }
        
        // 如果网络不存在，需要创建并添加
        if netStatus == nil {
            logger.Info("New network detected, creating and attaching", "network", network.Name)
            
            // 创建 NAD（如果需要）
            nadName, err := r.reconcileNetwork(ctx, network, vmp)
            if err != nil {
                return err
            }
            
            // 如果 VMI 运行中，动态添加
            if vmiExists {
                if err := network.AttachNetwork(ctx, r.Client, vmName, vmp.Namespace, network); err != nil {
                    logger.Error(err, "failed to attach network", "network", network.Name)
                    return err
                }
            }
            
            // 更新状态
            vmp.Status.Networks = append(vmp.Status.Networks, vmv1alpha1.NetworkStatus{
                Name:    network.Name,
                NADName: nadName,
                Type:    network.Type,
            })
        }
    }
    
    // 3. 检查需要移除的网络
    for i := len(vmp.Status.Networks) - 1; i >= 0; i-- {
        net := vmp.Status.Networks[i]
        if !specNetworks[net.Name] {
            logger.Info("Network removed from spec, detaching", "network", net.Name)
            
            // 如果 VMI 运行中，动态移除
            if vmiExists {
                if err := network.DetachNetwork(ctx, r.Client, vmName, vmp.Namespace, net.Name); err != nil {
                    logger.Error(err, "failed to detach network", "network", net.Name)
                    // 继续处理其他网络
                }
            }
            
            // 从状态中移除
            vmp.Status.Networks = append(vmp.Status.Networks[:i], vmp.Status.Networks[i+1:]...)
        }
    }
    
    return r.Status().Update(ctx, vmp)
}
```

## 4. API 设计

### 4.1 动态添加网络

```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: my-vm
spec:
  cpu: 2
  memory: 4Gi
  networks:
  - name: eth0
    type: bridge
  - name: eth1  # 新添加的网络
    type: macvlan
    vlanId: 100
```

### 4.2 动态删除网络

```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: my-vm
spec:
  cpu: 2
  memory: 4Gi
  networks:
  - name: eth0
    type: bridge
  # eth1 网络已移除
```

### 4.3 网络配置更新

```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: my-vm
spec:
  networks:
  - name: eth0
    type: bridge
    ipConfig:
      mode: static
      address: "192.168.1.100/24"  # 更新 IP 地址
```

## 5. 使用示例

### 5.1 运行时添加网络
```yaml
# 更新 Wukong，添加新网络
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: my-vm
spec:
  networks:
  - name: eth0
    type: bridge
  - name: eth1  # 新网络
    type: macvlan
    vlanId: 100
```

### 5.2 运行时移除网络
```yaml
# 更新 Wukong，移除网络
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: my-vm
spec:
  networks:
  - name: eth0
    type: bridge
  # eth1 网络已移除
```

## 6. 注意事项

### 6.1 热插拔支持
- 需要 VM 内操作系统支持网络热插拔
- Linux 通常支持网络接口热插拔
- 某些网络类型可能不支持热插拔

### 6.2 网络配置
- 添加网络后需要配置 IP 地址
- 可以通过 Cloud-Init 或 NMState 配置
- 某些网络类型需要特殊配置

### 6.3 主网络限制
- 主网络（通常是第一个）不能删除
- 需要标识主网络
- 提供保护机制

### 6.4 NAD 管理
- 动态创建的 NAD 需要管理生命周期
- 共享的 NAD 不能删除
- 提供 NAD 清理机制

## 7. 面试要点

### 7.1 如何实现动态添加网络接口？

**答案**:
1. 创建或获取 NAD（如果需要）
2. 更新 VirtualMachineInstance 的 Networks 和 Interfaces
3. KubeVirt 通过 QEMU 热插拔网络接口
4. VM 内操作系统识别新网络接口
5. 配置网络（IP 地址等）

### 7.2 网络热插拔的限制？

**答案**:
- 需要操作系统支持网络热插拔
- 某些网络类型可能不支持
- 主网络不能删除
- 需要正确配置网络参数

### 7.3 如何管理 NAD 的生命周期？

**答案**:
- 检查 NAD 是否被其他 VM 使用
- 动态创建的 NAD 在删除网络时清理
- 共享的 NAD 保留不删除
- 提供 NAD 管理策略

