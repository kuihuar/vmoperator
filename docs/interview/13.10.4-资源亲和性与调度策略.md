# 资源亲和性与调度策略

## 1. 功能概述

### 1.1 资源亲和性
基于节点资源（CPU、内存、存储、GPU等）进行调度决策。

**使用场景**:
- 调度到资源充足的节点
- 避免资源碎片化
- 资源优化分配
- 特殊资源需求（GPU、FPGA等）

### 1.2 调度策略
自定义调度规则和策略，实现更灵活的调度逻辑。

**使用场景**:
- 自定义调度优先级
- 多因素调度决策
- 调度器扩展
- 调度策略管理

## 2. 当前实现状态

### 2.1 已实现
- ✅ **资源请求**: 通过 CPU 和 Memory 指定资源需求
- ❌ 无资源亲和性功能
- ❌ 无调度策略功能

### 2.2 待实现
- ❌ **资源亲和性**: 基于资源的调度
- ❌ **资源感知调度**: 感知节点资源状态
- ❌ **调度策略**: 自定义调度规则
- ❌ **调度器扩展**: 支持自定义调度器

## 3. 技术实现

### 3.1 资源亲和性实现

```go
// api/v1alpha1/wukong_types.go

type SchedulingSpec struct {
    // ... 现有字段 ...
    
    // ResourceAffinity 资源亲和性
    // +optional
    ResourceAffinity *ResourceAffinitySpec `json:"resourceAffinity,omitempty"`
    
    // SchedulingPolicy 调度策略
    // +optional
    SchedulingPolicy *SchedulingPolicySpec `json:"schedulingPolicy,omitempty"`
}

type ResourceAffinitySpec struct {
    // PreferredCPU 优先选择 CPU 充足的节点
    // +optional
    PreferredCPU *ResourcePreferenceSpec `json:"preferredCPU,omitempty"`
    
    // PreferredMemory 优先选择内存充足的节点
    // +optional
    PreferredMemory *ResourcePreferenceSpec `json:"preferredMemory,omitempty"`
    
    // PreferredStorage 优先选择存储充足的节点
    // +optional
    PreferredStorage *ResourcePreferenceSpec `json:"preferredStorage,omitempty"`
    
    // RequiredResources 必须满足的资源条件
    // +optional
    RequiredResources []ResourceRequirementSpec `json:"requiredResources,omitempty"`
}

type ResourcePreferenceSpec struct {
    // Weight 权重（1-100）
    Weight int32 `json:"weight"`
    
    // Threshold 资源阈值（如 "80%" 表示使用率低于 80%）
    Threshold string `json:"threshold"`
}

type ResourceRequirementSpec struct {
    // ResourceType 资源类型: cpu, memory, storage, gpu
    ResourceType string `json:"resourceType"`
    
    // MinAvailable 最小可用资源（如 "4Gi"）
    MinAvailable string `json:"minAvailable"`
}
```

### 3.2 调度策略实现

```go
// api/v1alpha1/wukong_types.go

type SchedulingPolicySpec struct {
    // SchedulerName 调度器名称（使用自定义调度器）
    // +optional
    SchedulerName string `json:"schedulerName,omitempty"`
    
    // Priority 调度优先级（数字越大优先级越高）
    // +optional
    Priority *int32 `json:"priority,omitempty"`
    
    // PreemptionPolicy 抢占策略: Never, PreemptLowerPriority
    // +optional
    PreemptionPolicy string `json:"preemptionPolicy,omitempty"`
    
    // Rules 自定义调度规则
    // +optional
    Rules []SchedulingRuleSpec `json:"rules,omitempty"`
}

type SchedulingRuleSpec struct {
    // Name 规则名称
    Name string `json:"name"`
    
    // Type 规则类型: score, filter, prioritize
    Type string `json:"type"`
    
    // Weight 权重（用于 score 类型）
    // +optional
    Weight *int32 `json:"weight,omitempty"`
    
    // Config 规则配置（JSON 格式）
    // +optional
    Config map[string]interface{} `json:"config,omitempty"`
}
```

### 3.3 Controller 实现

```go
// pkg/kubevirt/scheduling.go

func buildResourceAffinity(vmp *vmv1alpha1.Wukong) []corev1.PreferredSchedulingTerm {
    if vmp.Spec.Scheduling == nil || vmp.Spec.Scheduling.ResourceAffinity == nil {
        return nil
    }
    
    preferredTerms := make([]corev1.PreferredSchedulingTerm, 0)
    ra := vmp.Spec.Scheduling.ResourceAffinity
    
    // CPU 亲和性
    if ra.PreferredCPU != nil {
        preferredTerms = append(preferredTerms, buildResourcePreference(
            "cpu-usage",
            ra.PreferredCPU.Weight,
            ra.PreferredCPU.Threshold,
        ))
    }
    
    // Memory 亲和性
    if ra.PreferredMemory != nil {
        preferredTerms = append(preferredTerms, buildResourcePreference(
            "memory-usage",
            ra.PreferredMemory.Weight,
            ra.PreferredMemory.Threshold,
        ))
    }
    
    return preferredTerms
}

func buildResourcePreference(key string, weight int32, threshold string) corev1.PreferredSchedulingTerm {
    // 这里需要将资源阈值转换为节点选择表达式
    // 实际实现可能需要自定义调度器或使用节点标签
    
    return corev1.PreferredSchedulingTerm{
        Weight: weight,
        Preference: corev1.NodeSelectorTerm{
            MatchExpressions: []corev1.NodeSelectorRequirement{
                {
                    Key:      fmt.Sprintf("resource.%s", key),
                    Operator: corev1.NodeSelectorOpLt,  // 小于阈值
                    Values:   []string{threshold},
                },
            },
        },
    }
}
```

## 4. API 设计

### 4.1 使用示例

#### 资源亲和性
```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: resource-aware-vm
spec:
  cpu: 4
  memory: 8Gi
  scheduling:
    resourceAffinity:
      preferredCPU:
        weight: 80
        threshold: "70%"  # 优先选择 CPU 使用率低于 70% 的节点
      preferredMemory:
        weight: 60
        threshold: "80%"  # 优先选择内存使用率低于 80% 的节点
      requiredResources:
      - resourceType: gpu
        minAvailable: "1"
```

#### 调度策略
```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: custom-scheduled-vm
spec:
  scheduling:
    schedulingPolicy:
      schedulerName: "custom-scheduler"
      priority: 100
      preemptionPolicy: "PreemptLowerPriority"
      rules:
      - name: "cost-aware"
        type: "score"
        weight: 50
        config:
          costFactor: 0.3
```

#### 自定义调度器
```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: gpu-vm
spec:
  scheduling:
    schedulingPolicy:
      schedulerName: "gpu-scheduler"  # 使用 GPU 专用调度器
```

## 5. 实现方案

### 5.1 资源感知调度

#### 方案一：使用节点标签
- 节点控制器定期更新资源使用率标签
- 使用节点亲和性基于标签调度
- 简单但可能不够实时

#### 方案二：自定义调度器
- 实现自定义调度器
- 实时查询节点资源
- 更灵活但实现复杂

#### 方案三：调度器扩展
- 使用调度器框架（Scheduler Framework）
- 实现扩展点（Filter、Score等）
- 平衡灵活性和复杂度

### 5.2 调度策略实现

```go
// pkg/scheduler/policy.go

func ApplySchedulingPolicy(ctx context.Context, c client.Client, vmp *vmv1alpha1.Wukong) error {
    if vmp.Spec.Scheduling == nil || vmp.Spec.Scheduling.SchedulingPolicy == nil {
        return nil
    }
    
    policy := vmp.Spec.Scheduling.SchedulingPolicy
    
    // 1. 设置调度器名称
    if policy.SchedulerName != "" {
        // 在 VirtualMachine 的 Annotation 中设置
        // 或通过其他方式指定调度器
    }
    
    // 2. 设置优先级（如果支持 PriorityClass）
    if policy.Priority != nil {
        priorityClass := &schedulingv1.PriorityClass{
            ObjectMeta: metav1.ObjectMeta{
                Name: fmt.Sprintf("wukong-%s-priority", vmp.Name),
            },
            Value: *policy.Priority,
        }
        // 创建或更新 PriorityClass
    }
    
    // 3. 应用自定义规则
    for _, rule := range policy.Rules {
        if err := applySchedulingRule(ctx, c, vmp, rule); err != nil {
            return err
        }
    }
    
    return nil
}
```

## 6. 注意事项

### 6.1 资源感知
- 资源使用率可能频繁变化
- 需要平衡实时性和性能
- 考虑使用缓存减少查询

### 6.2 调度策略
- 自定义调度器需要额外开发
- 调度器扩展需要了解调度器框架
- 提供默认调度策略

### 6.3 性能影响
- 复杂的调度规则可能影响调度性能
- 需要优化调度算法
- 监控调度延迟

## 7. 面试要点

### 7.1 如何实现资源感知调度？

**答案**:
- 使用节点标签记录资源使用率
- 使用节点亲和性基于标签调度
- 实现自定义调度器实时查询资源
- 使用调度器框架扩展调度逻辑

### 7.2 自定义调度器的实现方式？

**答案**:
- 实现 Kubernetes 调度器接口
- 使用调度器框架（Scheduler Framework）
- 实现 Filter、Score 等扩展点
- 注册为自定义调度器

### 7.3 调度策略和亲和性的关系？

**答案**:
- **亲和性**: 定义调度约束（必须或优先）
- **调度策略**: 定义调度逻辑和优先级
- 两者可以结合使用，实现更灵活的调度

