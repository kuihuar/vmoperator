# 文件传输

## 1. 功能概述

### 1.1 文件传输
在 VM 和外部之间传输文件，支持上传和下载。

**使用场景**:
- 上传配置文件
- 下载日志文件
- 应用部署
- 数据备份

### 1.2 传输方式
- **SCP/SFTP**: 通过 SSH 传输
- **HTTP/HTTPS**: 通过 Web 服务传输
- **PVC 挂载**: 通过 PVC 共享文件
- **Cloud-Init**: 通过 Cloud-Init 注入文件

## 2. 当前实现状态

### 2.1 已实现
- ✅ **Cloud-Init**: 通过 Cloud-Init 可以注入文件（有限支持）

### 2.2 待实现
- ❌ **文件上传**: 运行时上传文件到 VM
- ❌ **文件下载**: 从 VM 下载文件
- ❌ **批量传输**: 批量文件传输
- ❌ **传输进度**: 传输进度显示

## 3. 技术实现

### 3.1 实现方案

#### 方案一：通过 SSH
```go
// pkg/filetransfer/ssh.go

func UploadFileViaSSH(ctx context.Context, vmName, namespace, localPath, remotePath string) error {
    // 1. 获取 VM 的 IP 地址
    ip, err := getVMIP(ctx, vmName, namespace)
    if err != nil {
        return err
    }
    
    // 2. 获取 SSH 密钥
    key, err := getSSHKey(ctx, namespace)
    if err != nil {
        return err
    }
    
    // 3. 通过 SCP 上传文件
    return scpUpload(ip, key, localPath, remotePath)
}

func DownloadFileViaSSH(ctx context.Context, vmName, namespace, remotePath, localPath string) error {
    // 1. 获取 VM 的 IP 地址
    ip, err := getVMIP(ctx, vmName, namespace)
    if err != nil {
        return err
    }
    
    // 2. 获取 SSH 密钥
    key, err := getSSHKey(ctx, namespace)
    if err != nil {
        return err
    }
    
    // 3. 通过 SCP 下载文件
    return scpDownload(ip, key, remotePath, localPath)
}
```

#### 方案二：通过 PVC 挂载
```go
// pkg/filetransfer/pvc.go

func UploadFileViaPVC(ctx context.Context, c client.Client, vmName, namespace, localPath string) error {
    // 1. 创建临时 PVC
    pvc := &corev1.PersistentVolumeClaim{
        ObjectMeta: metav1.ObjectMeta{
            Name:      fmt.Sprintf("%s-upload-temp", vmName),
            Namespace: namespace,
        },
        Spec: corev1.PersistentVolumeClaimSpec{
            AccessModes: []corev1.PersistentVolumeAccessMode{corev1.ReadWriteOnce},
            Resources: corev1.ResourceRequirements{
                Requests: corev1.ResourceList{
                    corev1.ResourceStorage: resource.MustParse("1Gi"),
                },
            },
        },
    }
    
    if err := c.Create(ctx, pvc); err != nil {
        return err
    }
    
    // 2. 创建临时 Pod 挂载 PVC
    pod := createUploadPod(vmName, namespace, pvc.Name)
    if err := c.Create(ctx, pod); err != nil {
        return err
    }
    
    // 3. 复制文件到 Pod
    if err := copyFileToPod(pod.Name, namespace, localPath); err != nil {
        return err
    }
    
    // 4. 在 VM 中挂载 PVC 并复制文件
    return mountPVCAndCopy(vmName, namespace, pvc.Name)
}
```

#### 方案三：通过 HTTP 服务
```go
// pkg/filetransfer/http.go

func CreateFileTransferService(ctx context.Context, c client.Client, vmName, namespace string) error {
    // 1. 在 VM 内启动文件传输服务（通过 Cloud-Init 或 SSH）
    // 2. 创建 Service 暴露服务
    // 3. 通过 HTTP API 上传/下载文件
    
    service := &corev1.Service{
        ObjectMeta: metav1.ObjectMeta{
            Name:      fmt.Sprintf("%s-filetransfer", vmName),
            Namespace: namespace,
        },
        Spec: corev1.ServiceSpec{
            Type: corev1.ServiceTypeNodePort,
            Selector: map[string]string{
                "kubevirt.io/vm": vmName,
            },
            Ports: []corev1.ServicePort{
                {
                    Name:       "filetransfer",
                    Port:       8080,
                    TargetPort: intstr.FromInt(8080),
                },
            },
        },
    }
    
    return c.Create(ctx, service)
}
```

## 4. API 设计

### 4.1 WukongSpec 扩展

```go
// api/v1alpha1/wukong_types.go

type WukongSpec struct {
    // ... 现有字段 ...
    
    // FileTransfer 文件传输配置（可选）
    // +optional
    FileTransfer *FileTransferSpec `json:"fileTransfer,omitempty"`
}

type FileTransferSpec struct {
    // Enabled 是否启用文件传输
    Enabled bool `json:"enabled"`
    
    // Method 传输方式: ssh, pvc, http
    Method string `json:"method"`
    
    // SSHConfig SSH 配置（用于 ssh 方式）
    // +optional
    SSHConfig *SSHTransferConfig `json:"sshConfig,omitempty"`
    
    // HTTPConfig HTTP 配置（用于 http 方式）
    // +optional
    HTTPConfig *HTTPTransferConfig `json:"httpConfig,omitempty"`
}

type SSHTransferConfig struct {
    // User SSH 用户名
    User string `json:"user"`
    
    // KeySecret SSH 密钥 Secret 名称
    KeySecret string `json:"keySecret"`
    
    // Port SSH 端口（默认 22）
    // +optional
    Port *int32 `json:"port,omitempty"`
}

type HTTPTransferConfig struct {
    // Enabled 是否启用 HTTP 文件传输服务
    Enabled bool `json:"enabled"`
    
    // Port HTTP 服务端口（默认 8080）
    // +optional
    Port *int32 `json:"port,omitempty"`
    
    // ServiceExposure Service 暴露配置
    // +optional
    ServiceExposure *ServiceExposureSpec `json:"serviceExposure,omitempty"`
}
```

### 4.2 文件传输操作 API

```go
// api/v1alpha1/wukong_filetransfer_types.go

// WukongFileTransfer 文件传输操作资源
type WukongFileTransfer struct {
    metav1.TypeMeta   `json:",inline"`
    metav1.ObjectMeta `json:"metadata,omitempty"`
    
    Spec   WukongFileTransferSpec   `json:"spec,omitempty"`
    Status WukongFileTransferStatus `json:"status,omitempty"`
}

type WukongFileTransferSpec struct {
    // WukongName 目标 Wukong 名称
    WukongName string `json:"wukongName"`
    
    // Operation 操作类型: upload, download
    Operation string `json:"operation"`
    
    // LocalPath 本地路径
    LocalPath string `json:"localPath"`
    
    // RemotePath 远程路径（VM 内路径）
    RemotePath string `json:"remotePath"`
    
    // Method 传输方式: ssh, pvc, http
    Method string `json:"method"`
}

type WukongFileTransferStatus struct {
    Phase     string `json:"phase"`     // Pending, Transferring, Succeeded, Failed
    Progress  string `json:"progress"`  // 0-100%
    Message   string `json:"message,omitempty"`
    StartedAt metav1.Time `json:"startedAt,omitempty"`
    CompletedAt metav1.Time `json:"completedAt,omitempty"`
}
```

## 5. 使用示例

### 5.1 通过 SSH 上传文件
```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: WukongFileTransfer
metadata:
  name: upload-config
spec:
  wukongName: my-vm
  operation: upload
  localPath: "/tmp/config.yaml"
  remotePath: "/etc/app/config.yaml"
  method: ssh
```

### 5.2 通过 PVC 传输文件
```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: WukongFileTransfer
metadata:
  name: transfer-data
spec:
  wukongName: my-vm
  operation: upload
  localPath: "/tmp/data.tar.gz"
  remotePath: "/data/backup.tar.gz"
  method: pvc
```

### 5.3 启用 HTTP 文件传输
```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: filetransfer-vm
spec:
  fileTransfer:
    enabled: true
    method: http
    httpConfig:
      enabled: true
      port: 8080
      serviceExposure:
        enabled: true
        type: NodePort
```

## 6. Controller 实现

```go
// internal/controller/wukong_filetransfer_controller.go

func (r *WukongFileTransferReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
    transfer := &vmv1alpha1.WukongFileTransfer{}
    if err := r.Get(ctx, req.NamespacedName, transfer); err != nil {
        return ctrl.Result{}, client.IgnoreNotFound(err)
    }
    
    logger := log.FromContext(ctx)
    
    // 更新状态为传输中
    transfer.Status.Phase = "Transferring"
    transfer.Status.StartedAt = metav1.Now()
    r.Status().Update(ctx, transfer)
    
    // 执行文件传输
    var err error
    switch transfer.Spec.Operation {
    case "upload":
        err = r.uploadFile(ctx, transfer)
    case "download":
        err = r.downloadFile(ctx, transfer)
    default:
        err = fmt.Errorf("unknown operation: %s", transfer.Spec.Operation)
    }
    
    if err != nil {
        transfer.Status.Phase = "Failed"
        transfer.Status.Message = err.Error()
    } else {
        transfer.Status.Phase = "Succeeded"
        transfer.Status.Progress = "100%"
        transfer.Status.CompletedAt = metav1.Now()
    }
    
    r.Status().Update(ctx, transfer)
    return ctrl.Result{}, err
}
```

## 7. 注意事项

### 7.1 安全性
- SSH 传输需要密钥管理
- HTTP 传输需要认证
- 验证文件路径安全性
- 限制文件大小

### 7.2 性能
- 大文件传输可能耗时
- 需要显示传输进度
- 支持断点续传
- 考虑压缩传输

### 7.3 错误处理
- 网络中断处理
- 文件不存在处理
- 权限不足处理
- 存储空间不足处理

## 8. 面试要点

### 8.1 文件传输的实现方式？

**答案**:
- **SSH/SCP**: 通过 SSH 连接传输，需要密钥
- **PVC 挂载**: 通过共享存储传输，适合大文件
- **HTTP 服务**: 通过 HTTP API 传输，需要服务支持

### 8.2 如何实现大文件传输？

**答案**:
- 使用 PVC 挂载方式
- 支持断点续传
- 使用压缩减少传输时间
- 显示传输进度

### 8.3 文件传输的安全考虑？

**答案**:
- 使用 SSH 密钥认证
- HTTP 传输使用 TLS
- 验证文件路径
- 限制文件大小和类型
- 记录传输日志

