# 重启功能

## 1. 功能概述

### 1.1 重启功能
重启运行中的 VM，使其重新启动。

**使用场景**:
- 应用配置更新后重启
- 系统故障恢复
- 定期维护重启
- 性能问题排查

### 1.2 重启类型

#### 优雅重启（Graceful Restart）
- 先优雅关闭，再启动
- 保证数据一致性
- 需要等待时间

#### 强制重启（Force Restart）
- 强制停止后立即启动
- 速度快但可能丢失数据
- 仅在必要时使用

## 2. 当前实现状态

### 2.1 已实现
- ❌ 无重启功能

### 2.2 待实现
- ❌ 优雅重启
- ❌ 强制重启
- ❌ 重启状态跟踪
- ❌ 重启超时处理

## 3. 技术实现

### 3.1 实现方案

```go
// pkg/kubevirt/lifecycle.go

func RestartVM(ctx context.Context, c client.Client, vmName, namespace string, force bool) error {
    logger := log.FromContext(ctx)
    
    // 1. 获取 VirtualMachine
    vm := &kubevirtv1.VirtualMachine{}
    key := client.ObjectKey{Name: vmName, Namespace: namespace}
    if err := c.Get(ctx, key, vm); err != nil {
        return fmt.Errorf("VM not found: %w", err)
    }
    
    // 2. 检查当前状态
    if vm.Spec.Running == nil || !*vm.Spec.Running {
        // VM 未运行，直接启动
        running := true
        vm.Spec.Running = &running
        return c.Update(ctx, vm)
    }
    
    // 3. 重启流程
    if force {
        // 强制重启：直接删除 VMI，然后启动
        return forceRestartVM(ctx, c, vmName, namespace)
    } else {
        // 优雅重启：先停止，再启动
        return gracefulRestartVM(ctx, c, vmName, namespace)
    }
}

func gracefulRestartVM(ctx context.Context, c client.Client, vmName, namespace string) error {
    logger := log.FromContext(ctx)
    
    // 1. 停止 VMI（优雅关闭）
    if err := stopVMI(ctx, c, vmName, namespace); err != nil {
        return fmt.Errorf("failed to stop VMI: %w", err)
    }
    
    // 2. 等待 VMI 完全停止
    timeout := 60 * time.Second
    if err := waitForVMStopped(ctx, c, vmName, namespace, timeout); err != nil {
        logger.Warn("timeout waiting for VM to stop, forcing restart", "error", err)
        // 超时后强制停止
        return forceRestartVM(ctx, c, vmName, namespace)
    }
    
    // 3. 启动 VM
    vm := &kubevirtv1.VirtualMachine{}
    key := client.ObjectKey{Name: vmName, Namespace: namespace}
    if err := c.Get(ctx, key, vm); err != nil {
        return err
    }
    
    running := true
    vm.Spec.Running = &running
    return c.Update(ctx, vm)
}

func forceRestartVM(ctx context.Context, c client.Client, vmName, namespace string) error {
    logger := log.FromContext(ctx)
    
    // 1. 强制删除 VMI
    vmi := &kubevirtv1.VirtualMachineInstance{}
    key := client.ObjectKey{Name: vmName, Namespace: namespace}
    if err := c.Get(ctx, key, vmi); err != nil {
        if !errors.IsNotFound(err) {
            return err
        }
        // VMI 不存在，直接启动
    } else {
        // 强制删除 VMI
        if err := c.Delete(ctx, vmi, &client.DeleteOptions{GracePeriodSeconds: &[]int64{0}[0]}); err != nil {
            return fmt.Errorf("failed to delete VMI: %w", err)
        }
        
        // 等待 VMI 删除完成
        if err := waitForVMDeleted(ctx, c, vmName, namespace, 30*time.Second); err != nil {
            logger.Warn("timeout waiting for VMI to be deleted", "error", err)
        }
    }
    
    // 2. 启动 VM
    vm := &kubevirtv1.VirtualMachine{}
    key = client.ObjectKey{Name: vmName, Namespace: namespace}
    if err := c.Get(ctx, key, vm); err != nil {
        return err
    }
    
    running := true
    vm.Spec.Running = &running
    return c.Update(ctx, vm)
}
```

### 3.2 Controller 实现

```go
// internal/controller/wukong_controller.go

func (r *WukongReconciler) restartVM(ctx context.Context, vmName string, vmp *vmv1alpha1.Wukong) error {
    logger := log.FromContext(ctx)
    
    action := vmp.Spec.LifecycleAction
    force := action.Force
    
    // 更新状态为重启中
    vmp.Status.LifecycleState = &vmv1alpha1.LifecycleState{
        State:       "Restarting",
        LastAction: "restart",
        LastActionTime: metav1.Now(),
    }
    r.Status().Update(ctx, vmp)
    
    // 执行重启
    if err := kubevirt.RestartVM(ctx, r.Client, vmName, vmp.Namespace, force); err != nil {
        vmp.Status.LifecycleState.Message = fmt.Sprintf("Restart failed: %v", err)
        r.Status().Update(ctx, vmp)
        return err
    }
    
    logger.Info("VM restarted", "vm", vmName, "force", force)
    
    // 等待 VM 启动
    if err := r.waitForVMRunning(ctx, vmName, vmp.Namespace, 120*time.Second); err != nil {
        vmp.Status.LifecycleState.Message = fmt.Sprintf("VM started but not ready: %v", err)
        r.Status().Update(ctx, vmp)
        return err
    }
    
    // 更新状态为运行中
    vmp.Status.LifecycleState = &vmv1alpha1.LifecycleState{
        State:       "Running",
        LastAction:  "restart",
        LastActionTime: metav1.Now(),
    }
    r.Status().Update(ctx, vmp)
    
    // 清除 lifecycleAction
    vmp.Spec.LifecycleAction = nil
    return r.Update(ctx, vmp)
}

func (r *WukongReconciler) waitForVMRunning(ctx context.Context, vmName, namespace string, timeout time.Duration) error {
    deadline := time.Now().Add(timeout)
    ticker := time.NewTicker(2 * time.Second)
    defer ticker.Stop()
    
    for {
        select {
        case <-ctx.Done():
            return ctx.Err()
        case <-ticker.C:
            if time.Now().After(deadline) {
                return fmt.Errorf("timeout waiting for VM to start")
            }
            
            vmi := &kubevirtv1.VirtualMachineInstance{}
            key := client.ObjectKey{Name: vmName, Namespace: namespace}
            if err := r.Get(ctx, key, vmi); err != nil {
                if errors.IsNotFound(err) {
                    // VMI 还未创建，继续等待
                    continue
                }
                return err
            }
            
            // 检查 VMI 状态
            if vmi.Status.Phase == kubevirtv1.Running {
                // 检查是否就绪
                if vmi.Status.Conditions != nil {
                    for _, condition := range vmi.Status.Conditions {
                        if condition.Type == kubevirtv1.VirtualMachineInstanceReady &&
                           condition.Status == corev1.ConditionTrue {
                            return nil
                        }
                    }
                }
            }
        }
    }
}
```

## 4. API 设计

### 4.1 使用示例

```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: my-vm
spec:
  cpu: 2
  memory: 4Gi
  lifecycleAction:
    action: restart
    force: false  # 优雅重启
```

### 4.2 强制重启

```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: my-vm
spec:
  cpu: 2
  memory: 4Gi
  lifecycleAction:
    action: restart
    force: true  # 强制重启
```

## 5. 注意事项

### 5.1 优雅重启
- 需要等待 VM 完全停止
- 可能耗时较长
- 保证数据一致性

### 5.2 强制重启
- 速度快但可能丢失数据
- 仅在必要时使用
- 记录强制重启原因

### 5.3 重启超时
- 设置合理的超时时间
- 超时后自动转为强制重启
- 记录超时事件

### 5.4 状态跟踪
- 跟踪重启过程状态
- 提供状态查询接口
- 记录重启历史

## 6. 面试要点

### 6.1 优雅重启和强制重启的区别？

**答案**:
- **优雅重启**: 先优雅关闭，再启动，保证数据一致性，但耗时较长
- **强制重启**: 直接删除 VMI 后启动，速度快但可能丢失数据

### 6.2 如何确保重启成功？

**答案**:
- 等待 VMI 完全停止
- 等待 VMI 重新创建并运行
- 检查 VMI 就绪状态
- 设置超时机制

### 6.3 重启失败如何处理？

**答案**:
- 检查资源是否充足
- 检查配置是否正确
- 记录错误日志
- 提供重试机制
- 更新状态为错误

