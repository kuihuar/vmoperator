# 启动与关机功能

## 1. 功能概述

### 1.1 启动功能
启动已停止的 VM，使其进入运行状态。

**使用场景**:
- 手动启动已停止的 VM
- 定时启动（结合 CronJob）
- 按需启动（节省资源）

### 1.2 关机功能
优雅关闭运行中的 VM，使其进入停止状态。

**使用场景**:
- 手动停止 VM
- 定时关机（节省资源）
- 维护前关闭 VM

## 2. 当前实现状态

### 2.1 已实现
- ✅ **创建时自动启动**: 通过 `StartStrategy.AutoStart` 控制
- ✅ **RunStrategy**: 支持 `Always`, `RerunOnFailure`, `Manual`

### 2.2 待实现
- ❌ **手动启动**: 通过 API 启动已停止的 VM
- ❌ **优雅关机**: 发送 ACPI 关机信号
- ❌ **强制关机**: 强制停止 VM
- ❌ **状态查询**: 查询 VM 运行状态

## 3. 技术实现

### 3.1 KubeVirt 实现方式

#### 方式一：修改 VirtualMachine running 字段
```go
// pkg/kubevirt/lifecycle.go

func StartVM(ctx context.Context, c client.Client, vmName, namespace string) error {
    vm := &kubevirtv1.VirtualMachine{}
    key := client.ObjectKey{Name: vmName, Namespace: namespace}
    if err := c.Get(ctx, key, vm); err != nil {
        return err
    }
    
    // 设置 running 为 true
    running := true
    vm.Spec.Running = &running
    
    return c.Update(ctx, vm)
}

func StopVM(ctx context.Context, c client.Client, vmName, namespace string, graceful bool) error {
    vm := &kubevirtv1.VirtualMachine{}
    key := client.ObjectKey{Name: vmName, Namespace: namespace}
    if err := c.Get(ctx, key, vm); err != nil {
        return err
    }
    
    if graceful {
        // 优雅关闭：先停止 VMI，再设置 running 为 false
        if err := stopVMI(ctx, c, vmName, namespace); err != nil {
            return err
        }
    }
    
    // 设置 running 为 false
    running := false
    vm.Spec.Running = &running
    
    return c.Update(ctx, vm)
}
```

#### 方式二：使用 Subresource API
```go
// pkg/kubevirt/lifecycle.go

func StartVMViaSubresource(ctx context.Context, restClient rest.Interface, vmName, namespace string) error {
    return restClient.Put().
        Namespace(namespace).
        Resource("virtualmachines").
        Name(vmName).
        SubResource("start").
        Do(ctx).
        Error()
}

func StopVMViaSubresource(ctx context.Context, restClient rest.Interface, vmName, namespace string) error {
    return restClient.Put().
        Namespace(namespace).
        Resource("virtualmachines").
        Name(vmName).
        SubResource("stop").
        Do(ctx).
        Error()
}
```

### 3.2 优雅关闭实现

```go
// pkg/kubevirt/lifecycle.go

func stopVMI(ctx context.Context, c client.Client, vmName, namespace string) error {
    // 1. 获取 VMI
    vmi := &kubevirtv1.VirtualMachineInstance{}
    key := client.ObjectKey{Name: vmName, Namespace: namespace}
    if err := c.Get(ctx, key, vmi); err != nil {
        if errors.IsNotFound(err) {
            // VMI 不存在，说明已经停止
            return nil
        }
        return err
    }
    
    // 2. 发送 ACPI 关机信号（通过删除 VMI）
    // KubeVirt 会自动处理优雅关闭
    return c.Delete(ctx, vmi)
}

func waitForVMStopped(ctx context.Context, c client.Client, vmName, namespace string, timeout time.Duration) error {
    deadline := time.Now().Add(timeout)
    ticker := time.NewTicker(2 * time.Second)
    defer ticker.Stop()
    
    for {
        select {
        case <-ctx.Done():
            return ctx.Err()
        case <-ticker.C:
            if time.Now().After(deadline) {
                return fmt.Errorf("timeout waiting for VM to stop")
            }
            
            vmi := &kubevirtv1.VirtualMachineInstance{}
            key := client.ObjectKey{Name: vmName, Namespace: namespace}
            if err := c.Get(ctx, key, vmi); err != nil {
                if errors.IsNotFound(err) {
                    // VMI 已删除，说明已停止
                    return nil
                }
                return err
            }
            
            // 检查 VMI 状态
            if vmi.Status.Phase == kubevirtv1.Succeeded || 
               vmi.Status.Phase == kubevirtv1.Failed {
                return nil
            }
        }
    }
}
```

## 4. API 设计

### 4.1 WukongSpec 扩展

```go
// api/v1alpha1/wukong_types.go

type LifecycleActionSpec struct {
    // Action 操作类型: start, stop
    Action string `json:"action"`
    
    // Force 是否强制操作（用于 stop）
    // +optional
    Force bool `json:"force,omitempty"`
    
    // GracePeriodSeconds 优雅关闭等待时间（秒）
    // +optional
    GracePeriodSeconds *int64 `json:"gracePeriodSeconds,omitempty"`
}
```

### 4.2 Controller 实现

```go
// internal/controller/wukong_controller.go

func (r *WukongReconciler) reconcileLifecycle(ctx context.Context, vmp *vmv1alpha1.Wukong) error {
    if vmp.Spec.LifecycleAction == nil {
        return nil
    }
    
    logger := log.FromContext(ctx)
    vmName := fmt.Sprintf("%s-vm", vmp.Name)
    
    action := vmp.Spec.LifecycleAction.Action
    
    switch action {
    case "start":
        return r.startVM(ctx, vmName, vmp)
    case "stop":
        return r.stopVM(ctx, vmName, vmp)
    default:
        return fmt.Errorf("unknown lifecycle action: %s", action)
    }
}

func (r *WukongReconciler) startVM(ctx context.Context, vmName string, vmp *vmv1alpha1.Wukong) error {
    logger := log.FromContext(ctx)
    
    // 1. 获取 VirtualMachine
    vm := &kubevirtv1.VirtualMachine{}
    key := client.ObjectKey{Name: vmName, Namespace: vmp.Namespace}
    if err := r.Get(ctx, key, vm); err != nil {
        return fmt.Errorf("VM not found: %w", err)
    }
    
    // 2. 检查当前状态
    if vm.Spec.Running != nil && *vm.Spec.Running {
        logger.Info("VM is already running", "vm", vmName)
        // 清除 lifecycleAction
        vmp.Spec.LifecycleAction = nil
        return r.Update(ctx, vmp)
    }
    
    // 3. 启动 VM
    running := true
    vm.Spec.Running = &running
    if err := r.Update(ctx, vm); err != nil {
        return fmt.Errorf("failed to start VM: %w", err)
    }
    
    logger.Info("VM started", "vm", vmName)
    
    // 4. 更新状态
    vmp.Status.LifecycleState = &vmv1alpha1.LifecycleState{
        State:       "Starting",
        LastAction: "start",
        LastActionTime: metav1.Now(),
    }
    r.Status().Update(ctx, vmp)
    
    // 5. 清除 lifecycleAction
    vmp.Spec.LifecycleAction = nil
    return r.Update(ctx, vmp)
}

func (r *WukongReconciler) stopVM(ctx context.Context, vmName string, vmp *vmv1alpha1.Wukong) error {
    logger := log.FromContext(ctx)
    
    // 1. 获取 VirtualMachine
    vm := &kubevirtv1.VirtualMachine{}
    key := client.ObjectKey{Name: vmName, Namespace: vmp.Namespace}
    if err := r.Get(ctx, key, vm); err != nil {
        return fmt.Errorf("VM not found: %w", err)
    }
    
    // 2. 检查当前状态
    if vm.Spec.Running != nil && !*vm.Spec.Running {
        logger.Info("VM is already stopped", "vm", vmName)
        // 清除 lifecycleAction
        vmp.Spec.LifecycleAction = nil
        return r.Update(ctx, vmp)
    }
    
    // 3. 优雅关闭或强制关闭
    force := vmp.Spec.LifecycleAction.Force
    gracePeriod := int64(30) // 默认 30 秒
    if vmp.Spec.LifecycleAction.GracePeriodSeconds != nil {
        gracePeriod = *vmp.Spec.LifecycleAction.GracePeriodSeconds
    }
    
    if !force {
        // 优雅关闭
        if err := r.stopVMI(ctx, vmName, vmp.Namespace); err != nil {
            logger.Error(err, "failed to stop VMI gracefully")
            // 如果优雅关闭失败，尝试强制关闭
            force = true
        } else {
            // 等待 VMI 停止
            timeout := time.Duration(gracePeriod) * time.Second
            if err := r.waitForVMStopped(ctx, vmName, vmp.Namespace, timeout); err != nil {
                logger.Error(err, "timeout waiting for VM to stop, forcing stop")
                force = true
            }
        }
    }
    
    // 4. 设置 running 为 false
    running := false
    vm.Spec.Running = &running
    if err := r.Update(ctx, vm); err != nil {
        return fmt.Errorf("failed to stop VM: %w", err)
    }
    
    logger.Info("VM stopped", "vm", vmName, "force", force)
    
    // 5. 更新状态
    vmp.Status.LifecycleState = &vmv1alpha1.LifecycleState{
        State:       "Stopped",
        LastAction:  "stop",
        LastActionTime: metav1.Now(),
    }
    r.Status().Update(ctx, vmp)
    
    // 6. 清除 lifecycleAction
    vmp.Spec.LifecycleAction = nil
    return r.Update(ctx, vmp)
}
```

## 5. 使用示例

### 5.1 启动 VM
```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: my-vm
spec:
  cpu: 2
  memory: 4Gi
  lifecycleAction:
    action: start
```

### 5.2 优雅关机
```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: my-vm
spec:
  cpu: 2
  memory: 4Gi
  lifecycleAction:
    action: stop
    gracePeriodSeconds: 60  # 等待 60 秒
```

### 5.3 强制关机
```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: my-vm
spec:
  cpu: 2
  memory: 4Gi
  lifecycleAction:
    action: stop
    force: true
```

## 6. 状态查询

### 6.1 查询 VM 状态
```bash
kubectl get wukong my-vm -o jsonpath='{.status.lifecycleState.state}'
```

### 6.2 查询 VMI 状态
```bash
kubectl get vmi my-vm-vm -o jsonpath='{.status.phase}'
```

## 7. 注意事项

### 7.1 优雅关闭
- 需要 VM 内操作系统支持 ACPI
- 某些应用可能无法正常响应关机信号
- 设置合理的 GracePeriodSeconds

### 7.2 强制关闭
- 可能导致数据丢失
- 仅在优雅关闭失败时使用
- 记录强制关闭原因

### 7.3 状态同步
- VM 状态和 VMI 状态可能不同步
- 需要定期同步状态
- 处理状态不一致的情况

## 8. 面试要点

### 8.1 优雅关闭的实现原理？

**答案**:
- 发送 ACPI 关机信号到 VM
- VM 内操作系统接收信号并执行关机流程
- 等待应用正常退出
- 超时后强制关闭

### 8.2 如何确保 VM 真正停止？

**答案**:
- 检查 VMI 资源是否删除
- 检查 VMI 状态是否为 Succeeded/Failed
- 设置超时机制
- 定期轮询状态

### 8.3 启动失败如何处理？

**答案**:
- 检查资源是否充足（CPU、内存、存储）
- 检查网络配置是否正确
- 检查磁盘是否就绪
- 记录错误日志并更新状态

