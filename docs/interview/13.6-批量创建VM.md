# 批量创建 VM 功能规划

## 1. 功能概述

### 1.1 批量创建 VM
通过 Operator、Helm 或 StatefulSet 批量创建和管理多个 VM。

**使用场景**:
- 生产环境规模化部署
- 集群节点批量创建
- 测试环境快速搭建
- 负载均衡后端批量部署

### 1.2 实现方式

#### 方式一：基于 StatefulSet
- 使用 StatefulSet 管理 VM 生命周期
- 支持有序创建和删除
- 适合有状态服务

#### 方式二：基于 Operator
- 创建 WukongSet CRD
- 统一管理多个 Wukong 实例
- 支持模板和变量

#### 方式三：基于 Helm
- 使用 Helm Chart 批量部署
- 支持参数化配置
- 适合 CI/CD 集成

## 2. 当前实现状态

### 2.1 已实现
- ✅ 单个 Wukong CR 创建 VM
- ❌ 无批量创建功能

### 2.2 待实现
- ❌ WukongSet CRD
- ❌ 批量创建 Controller
- ❌ 模板和变量支持
- ❌ 状态聚合查询

## 3. 技术实现

### 3.1 方案一：WukongSet CRD（推荐）

```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: WukongSet
metadata:
  name: web-servers
spec:
  replicas: 5
  template:
    spec:
      cpu: 2
      memory: 4Gi
      disks:
      - name: system
        size: 20Gi
        image: docker://quay.io/kubevirt/ubuntu:22.04
  updateStrategy:
    type: RollingUpdate
    maxUnavailable: 1
  selector:
    matchLabels:
      app: web-server
```

### 3.2 方案二：基于 StatefulSet

```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: vm-set
spec:
  replicas: 5
  serviceName: vm-set
  template:
    metadata:
      labels:
        app: vm
    spec:
      containers:
      - name: vm-operator
        image: vm-operator:latest
        args:
        - create-vm
        - --template=vm-template.yaml
        - --index=$(POD_NAME)
```

### 3.3 方案三：基于 Helm

```yaml
# values.yaml
replicas: 5
vmTemplate:
  cpu: 2
  memory: 4Gi
  disks:
  - name: system
    size: 20Gi
    image: docker://quay.io/kubevirt/ubuntu:22.04
```

## 4. API 设计

### 4.1 WukongSet CRD

```go
// api/v1alpha1/wukong_set_types.go

package v1alpha1

import (
    metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// WukongSet 定义批量 VM 创建
type WukongSet struct {
    metav1.TypeMeta   `json:",inline"`
    metav1.ObjectMeta `json:"metadata,omitempty"`
    
    Spec   WukongSetSpec   `json:"spec,omitempty"`
    Status WukongSetStatus `json:"status,omitempty"`
}

type WukongSetSpec struct {
    // Replicas 要创建的 VM 数量
    Replicas int32 `json:"replicas"`
    
    // Template VM 模板
    Template WukongTemplateSpec `json:"template"`
    
    // UpdateStrategy 更新策略
    // +optional
    UpdateStrategy *UpdateStrategy `json:"updateStrategy,omitempty"`
    
    // Selector 选择器（用于管理）
    // +optional
    Selector *metav1.LabelSelector `json:"selector,omitempty"`
}

type WukongTemplateSpec struct {
    // Metadata 模板元数据
    // +optional
    Metadata metav1.ObjectMeta `json:"metadata,omitempty"`
    
    // Spec VM 规格
    Spec WukongSpec `json:"spec"`
}

type UpdateStrategy struct {
    // Type 更新类型: RollingUpdate, Recreate
    Type string `json:"type"`
    
    // RollingUpdate 滚动更新配置
    // +optional
    RollingUpdate *RollingUpdateStrategy `json:"rollingUpdate,omitempty"`
}

type RollingUpdateStrategy struct {
    // MaxUnavailable 最大不可用数量
    // +optional
    MaxUnavailable *int32 `json:"maxUnavailable,omitempty"`
    
    // MaxSurge 最大新增数量
    // +optional
    MaxSurge *int32 `json:"maxSurge,omitempty"`
}

type WukongSetStatus struct {
    // Replicas 当前副本数
    Replicas int32 `json:"replicas"`
    
    // ReadyReplicas 就绪副本数
    ReadyReplicas int32 `json:"readyReplicas"`
    
    // Conditions 状态条件
    // +optional
    Conditions []WukongSetCondition `json:"conditions,omitempty"`
}

type WukongSetCondition struct {
    Type    string `json:"type"`
    Status  string `json:"status"`
    Message string `json:"message,omitempty"`
    Reason  string `json:"reason,omitempty"`
}
```

## 5. Controller 实现

### 5.1 WukongSet Controller

```go
// internal/controller/wukong_set_controller.go

func (r *WukongSetReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
    wukongSet := &vmv1alpha1.WukongSet{}
    if err := r.Get(ctx, req.NamespacedName, wukongSet); err != nil {
        return ctrl.Result{}, client.IgnoreNotFound(err)
    }
    
    logger := log.FromContext(ctx)
    
    // 1. 获取当前所有 Wukong
    wukongs, err := r.getWukongsForSet(ctx, wukongSet)
    if err != nil {
        return ctrl.Result{}, err
    }
    
    // 2. 计算需要创建/删除的数量
    currentCount := int32(len(wukongs))
    desiredCount := wukongSet.Spec.Replicas
    
    if currentCount < desiredCount {
        // 需要创建
        toCreate := desiredCount - currentCount
        if err := r.createWukongs(ctx, wukongSet, toCreate, currentCount); err != nil {
            return ctrl.Result{}, err
        }
    } else if currentCount > desiredCount {
        // 需要删除
        toDelete := currentCount - desiredCount
        if err := r.deleteWukongs(ctx, wukongs, toDelete); err != nil {
            return ctrl.Result{}, err
        }
    }
    
    // 3. 更新状态
    return r.updateStatus(ctx, wukongSet)
}

func (r *WukongSetReconciler) createWukongs(ctx context.Context, wukongSet *vmv1alpha1.WukongSet, count int32, startIndex int32) error {
    for i := int32(0); i < count; i++ {
        index := startIndex + i
        wukong := r.buildWukongFromTemplate(wukongSet, index)
        if err := r.Create(ctx, wukong); err != nil {
            return err
        }
    }
    return nil
}

func (r *WukongSetReconciler) buildWukongFromTemplate(wukongSet *vmv1alpha1.WukongSet, index int32) *vmv1alpha1.Wukong {
    name := fmt.Sprintf("%s-%d", wukongSet.Name, index)
    
    wukong := &vmv1alpha1.Wukong{
        ObjectMeta: metav1.ObjectMeta{
            Name:      name,
            Namespace: wukongSet.Namespace,
            Labels:    wukongSet.Spec.Template.Metadata.Labels,
            OwnerReferences: []metav1.OwnerReference{
                {
                    APIVersion: wukongSet.APIVersion,
                    Kind:       wukongSet.Kind,
                    Name:       wukongSet.Name,
                    UID:        wukongSet.UID,
                    Controller: &[]bool{true}[0],
                },
            },
        },
        Spec: wukongSet.Spec.Template.Spec,
    }
    
    // 可以在这里替换模板变量，如 ${INDEX}, ${NAME} 等
    // r.replaceTemplateVariables(wukong, index)
    
    return wukong
}
```

## 6. 使用示例

### 6.1 基本批量创建
```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: WukongSet
metadata:
  name: web-servers
spec:
  replicas: 5
  template:
    metadata:
      labels:
        app: web-server
    spec:
      cpu: 2
      memory: 4Gi
      disks:
      - name: system
        size: 20Gi
        image: docker://quay.io/kubevirt/ubuntu:22.04
```

### 6.2 带更新策略
```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: WukongSet
metadata:
  name: app-servers
spec:
  replicas: 10
  updateStrategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 2
      maxSurge: 2
  template:
    spec:
      cpu: 4
      memory: 8Gi
      disks:
      - name: system
        size: 50Gi
        image: docker://quay.io/kubevirt/ubuntu:22.04
```

### 6.3 使用模板变量
```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: WukongSet
metadata:
  name: cluster-nodes
spec:
  replicas: 3
  template:
    metadata:
      labels:
        node-index: "${INDEX}"
    spec:
      cpu: 4
      memory: 8Gi
      networks:
      - name: eth0
        type: bridge
        ipConfig:
          mode: static
          address: "192.168.1.${INDEX+100}/24"  # 192.168.1.100, 101, 102
      disks:
      - name: system
        size: 50Gi
        image: docker://quay.io/kubevirt/ubuntu:22.04
```

## 7. 实现步骤

### 7.1 第一阶段：基础功能
1. 创建 WukongSet CRD
2. 实现基础 Controller
3. 支持创建和删除
4. 状态聚合

### 7.2 第二阶段：高级特性
1. 支持更新策略
2. 支持模板变量
3. 支持选择器
4. 支持条件查询

### 7.3 第三阶段：优化
1. 性能优化（批量操作）
2. 支持暂停/恢复
3. 支持扩缩容策略
4. 集成监控和告警

## 8. 注意事项

### 8.1 资源管理
- 批量创建可能消耗大量资源
- 需要实现资源配额检查
- 支持分批创建（避免资源耗尽）

### 8.2 性能优化
- 使用并发创建（控制并发数）
- 批量操作减少 API 调用
- 使用 Finalizer 管理生命周期

### 8.3 错误处理
- 部分创建失败的处理
- 重试机制
- 状态同步

## 9. 面试要点

### 9.1 为什么需要批量创建功能？

**答案**:
- **生产规模化**: 生产环境需要部署大量相同配置的 VM
- **效率提升**: 避免手动创建多个 VM
- **统一管理**: 通过统一接口管理多个 VM
- **自动化部署**: 支持 CI/CD 自动化

### 9.2 WukongSet 和 StatefulSet 的区别？

**答案**:
- **WukongSet**: 专门管理 VM，支持 VM 特有的配置和状态
- **StatefulSet**: 通用工作负载，需要额外配置才能管理 VM
- **WukongSet**: 更符合 Kubernetes Operator 模式
- **StatefulSet**: 更适合容器化应用

### 9.3 如何实现批量更新的零停机？

**答案**:
- 使用滚动更新策略
- 先创建新 VM，再删除旧 VM
- 确保新 VM 就绪后再删除旧 VM
- 支持健康检查确保服务可用

