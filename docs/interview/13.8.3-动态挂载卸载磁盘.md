# 动态挂载/卸载磁盘

## 1. 功能概述

### 1.1 动态挂载磁盘
在 VM 运行过程中添加新磁盘，无需重启 VM。

**使用场景**:
- 运行时添加数据盘
- 临时挂载存储
- 数据迁移
- 存储扩展

### 1.2 动态卸载磁盘
在 VM 运行过程中移除磁盘，无需重启 VM。

**使用场景**:
- 移除不需要的磁盘
- 数据迁移
- 存储回收
- 临时存储卸载

## 2. 当前实现状态

### 2.1 已实现
- ✅ **静态配置**: 创建时配置磁盘
- ✅ **磁盘管理**: 支持多个磁盘

### 2.2 待实现
- ❌ **动态挂载**: 运行时添加磁盘
- ❌ **动态卸载**: 运行时移除磁盘
- ❌ **热插拔支持**: VM 内热插拔识别
- ❌ **卸载验证**: 卸载前验证磁盘未使用

## 3. 技术实现

### 3.1 KubeVirt 支持

KubeVirt 支持动态添加/删除磁盘，通过修改 VirtualMachineInstance 的 Volumes 和 Disks。

### 3.2 实现方案

```go
// pkg/kubevirt/disk_management.go

func AttachDisk(ctx context.Context, c client.Client, vmName, namespace string, disk DiskConfig) error {
    // 1. 获取 VMI
    vmi := &kubevirtv1.VirtualMachineInstance{}
    key := client.ObjectKey{Name: vmName, Namespace: namespace}
    if err := c.Get(ctx, key, vmi); err != nil {
        return fmt.Errorf("VMI not found: %w", err)
    }
    
    // 2. 检查磁盘是否已存在
    for _, existingDisk := range vmi.Spec.Domain.Devices.Disks {
        if existingDisk.Name == disk.Name {
            return fmt.Errorf("disk %s already exists", disk.Name)
        }
    }
    
    // 3. 创建 PVC（如果不存在）
    pvcName := fmt.Sprintf("%s-%s", vmName, disk.Name)
    if err := createPVCIfNotExists(ctx, c, pvcName, namespace, disk); err != nil {
        return err
    }
    
    // 4. 添加磁盘到 VMI
    newDisk := kubevirtv1.Disk{
        Name: disk.Name,
        DiskDevice: kubevirtv1.DiskDevice{
            Disk: &kubevirtv1.DiskTarget{
                Bus: "virtio",
            },
        },
    }
    vmi.Spec.Domain.Devices.Disks = append(vmi.Spec.Domain.Devices.Disks, newDisk)
    
    // 5. 添加 Volume 到 VMI
    newVolume := kubevirtv1.Volume{
        Name: disk.Name,
        VolumeSource: kubevirtv1.VolumeSource{
            PersistentVolumeClaim: &kubevirtv1.PersistentVolumeClaimVolumeSource{
                PersistentVolumeClaimVolumeSource: corev1.PersistentVolumeClaimVolumeSource{
                    ClaimName: pvcName,
                },
            },
        },
    }
    vmi.Spec.Volumes = append(vmi.Spec.Volumes, newVolume)
    
    // 6. 更新 VMI
    return c.Update(ctx, vmi)
}

func DetachDisk(ctx context.Context, c client.Client, vmName, namespace, diskName string) error {
    // 1. 获取 VMI
    vmi := &kubevirtv1.VirtualMachineInstance{}
    key := client.ObjectKey{Name: vmName, Namespace: namespace}
    if err := c.Get(ctx, key, vmi); err != nil {
        return fmt.Errorf("VMI not found: %w", err)
    }
    
    // 2. 检查磁盘是否存在
    diskExists := false
    for _, disk := range vmi.Spec.Domain.Devices.Disks {
        if disk.Name == diskName {
            diskExists = true
            break
        }
    }
    if !diskExists {
        return fmt.Errorf("disk %s not found", diskName)
    }
    
    // 3. 验证磁盘未使用（可选，通过 QEMU Guest Agent）
    if err := verifyDiskNotInUse(ctx, c, vmi, diskName); err != nil {
        return fmt.Errorf("disk is in use: %w", err)
    }
    
    // 4. 从 VMI 中移除磁盘
    newDisks := make([]kubevirtv1.Disk, 0)
    for _, disk := range vmi.Spec.Domain.Devices.Disks {
        if disk.Name != diskName {
            newDisks = append(newDisks, disk)
        }
    }
    vmi.Spec.Domain.Devices.Disks = newDisks
    
    // 5. 从 VMI 中移除 Volume
    newVolumes := make([]kubevirtv1.Volume, 0)
    for _, volume := range vmi.Spec.Volumes {
        if volume.Name != diskName {
            newVolumes = append(newVolumes, volume)
        }
    }
    vmi.Spec.Volumes = newVolumes
    
    // 6. 更新 VMI
    return c.Update(ctx, vmi)
}

func verifyDiskNotInUse(ctx context.Context, c client.Client, vmi *kubevirtv1.VirtualMachineInstance, diskName string) error {
    // 通过 QEMU Guest Agent 或 SSH 检查磁盘是否被挂载
    // 这里简化处理，实际需要执行命令检查
    
    // 示例：检查 /dev/vdb 是否被挂载
    // mount | grep /dev/vdb
    
    // 如果无法检查，可以选择跳过验证（风险自负）
    return nil
}
```

### 3.3 Controller 实现

```go
// internal/controller/wukong_controller.go

func (r *WukongReconciler) reconcileDiskAttachment(ctx context.Context, vmp *vmv1alpha1.Wukong) error {
    logger := log.FromContext(ctx)
    vmName := fmt.Sprintf("%s-vm", vmp.Name)
    
    // 1. 获取当前 VMI（如果运行中）
    vmi := &kubevirtv1.VirtualMachineInstance{}
    key := client.ObjectKey{Name: vmName, Namespace: vmp.Namespace}
    vmiExists := r.Get(ctx, key, vmi) == nil && vmi.Status.Phase == kubevirtv1.Running
    
    // 2. 检查需要挂载的磁盘
    specDisks := make(map[string]bool)
    for _, disk := range vmp.Spec.Disks {
        specDisks[disk.Name] = true
        
        // 检查磁盘是否已挂载
        var volStatus *vmv1alpha1.VolumeStatus
        for i := range vmp.Status.Volumes {
            if vmp.Status.Volumes[i].Name == disk.Name {
                volStatus = &vmp.Status.Volumes[i]
                break
            }
        }
        
        // 如果磁盘不存在，需要创建并挂载
        if volStatus == nil {
            logger.Info("New disk detected, creating and attaching", "disk", disk.Name)
            
            // 创建 PVC
            pvcName, bound, err := r.reconcileDisk(ctx, disk, vmp)
            if err != nil {
                return err
            }
            
            // 如果 VMI 运行中，动态挂载
            if vmiExists && bound {
                if err := kubevirt.AttachDisk(ctx, r.Client, vmName, vmp.Namespace, disk); err != nil {
                    logger.Error(err, "failed to attach disk", "disk", disk.Name)
                    return err
                }
            }
            
            // 更新状态
            vmp.Status.Volumes = append(vmp.Status.Volumes, vmv1alpha1.VolumeStatus{
                Name:    disk.Name,
                PVCName: pvcName,
                Bound:   bound,
                Size:    disk.Size,
            })
        }
    }
    
    // 3. 检查需要卸载的磁盘
    for i := len(vmp.Status.Volumes) - 1; i >= 0; i-- {
        vol := vmp.Status.Volumes[i]
        if !specDisks[vol.Name] {
            logger.Info("Disk removed from spec, detaching", "disk", vol.Name)
            
            // 如果 VMI 运行中，动态卸载
            if vmiExists {
                if err := kubevirt.DetachDisk(ctx, r.Client, vmName, vmp.Namespace, vol.Name); err != nil {
                    logger.Error(err, "failed to detach disk", "disk", vol.Name)
                    // 继续处理其他磁盘
                }
            }
            
            // 从状态中移除
            vmp.Status.Volumes = append(vmp.Status.Volumes[:i], vmp.Status.Volumes[i+1:]...)
        }
    }
    
    return r.Status().Update(ctx, vmp)
}
```

## 4. API 设计

### 4.1 动态挂载磁盘

```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: my-vm
spec:
  cpu: 2
  memory: 4Gi
  disks:
  - name: system
    size: 20Gi
  - name: data  # 新添加的磁盘
    size: 100Gi
```

### 4.2 动态卸载磁盘

```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: my-vm
spec:
  cpu: 2
  memory: 4Gi
  disks:
  - name: system
    size: 20Gi
  # data 磁盘已移除
```

### 4.3 卸载选项

```go
// api/v1alpha1/wukong_types.go

type DiskConfig struct {
    // ... 现有字段 ...
    
    // DetachOptions 卸载选项（可选）
    // +optional
    DetachOptions *DetachOptionsSpec `json:"detachOptions,omitempty"`
}

type DetachOptionsSpec struct {
    // Force 是否强制卸载（即使磁盘在使用中）
    // +optional
    Force bool `json:"force,omitempty"`
    
    // PreserveData 是否保留数据（不删除 PVC）
    // +optional
    PreserveData bool `json:"preserveData,omitempty"`
}
```

## 5. 使用示例

### 5.1 运行时添加磁盘
```yaml
# 更新 Wukong，添加新磁盘
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: my-vm
spec:
  disks:
  - name: system
    size: 20Gi
  - name: data  # 新磁盘
    size: 100Gi
```

### 5.2 运行时移除磁盘
```yaml
# 更新 Wukong，移除磁盘
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: my-vm
spec:
  disks:
  - name: system
    size: 20Gi
  # data 磁盘已移除
```

## 6. 注意事项

### 6.1 热插拔支持
- 需要 VM 内操作系统支持热插拔
- Linux 通常支持 virtio 磁盘热插拔
- Windows 需要安装 virtio 驱动

### 6.2 卸载安全
- 卸载前检查磁盘是否被使用
- 确保数据已保存
- 提供强制卸载选项（风险自负）
- 记录卸载操作日志

### 6.3 数据保护
- 卸载时可以选择保留 PVC
- 提供数据迁移方案
- 卸载前建议备份数据

### 6.4 系统盘限制
- 系统盘不能卸载
- 需要标识系统盘
- 提供保护机制

## 7. 面试要点

### 7.1 如何实现动态挂载磁盘？

**答案**:
1. 创建 PVC（如果不存在）
2. 更新 VirtualMachineInstance 的 Disks 和 Volumes
3. KubeVirt 通过 QEMU 热插拔磁盘
4. VM 内操作系统识别新磁盘

### 7.2 卸载磁盘时如何保证数据安全？

**答案**:
- 检查磁盘是否被挂载
- 检查是否有进程在使用磁盘
- 提供强制卸载选项（风险自负）
- 可以选择保留 PVC 不删除

### 7.3 系统盘为什么不能卸载？

**答案**:
- 系统盘包含操作系统
- 卸载会导致 VM 无法启动
- 需要特殊保护机制
- 提供明确的错误提示

