# VNC 控制台

## 1. 功能概述

### 1.1 VNC 控制台
通过 VNC（Virtual Network Computing）协议提供 VM 的图形界面远程访问。

**使用场景**:
- 远程桌面访问
- 图形界面应用管理
- 故障排查和调试
- 用户交互

### 1.2 VNC 特点
- **简单**: 协议简单，兼容性好
- **跨平台**: 支持多种客户端
- **性能**: 性能一般，适合低带宽场景
- **安全**: 需要配置 TLS 加密

## 2. 当前实现状态

### 2.1 已实现
- ❌ 无 VNC 功能

### 2.2 待实现
- ❌ **VNC 配置**: 启用和配置 VNC
- ❌ **VNC 访问**: 提供 VNC 访问接口
- ❌ **TLS 加密**: VNC 连接加密
- ❌ **访问控制**: VNC 访问权限管理

## 3. 技术实现

### 3.1 KubeVirt 支持

KubeVirt 原生支持 VNC，通过 VirtualMachineInstance 的 Devices 配置：

```yaml
apiVersion: kubevirt.io/v1
kind: VirtualMachineInstance
spec:
  domain:
    devices:
      graphics:
      - type: VNC
        autoAttach: true
        listen:
          address: "0.0.0.0"
          type: address
```

### 3.2 实现方案

```go
// pkg/kubevirt/console.go

func buildGraphics(vmp *vmv1alpha1.Wukong) []kubevirtv1.Graphics {
    graphics := make([]kubevirtv1.Graphics, 0)
    
    if vmp.Spec.Console == nil {
        // 默认启用 VNC
        graphics = append(graphics, kubevirtv1.Graphics{
            Type:        "VNC",
            AutoAttach:  true,
        })
        return graphics
    }
    
    // VNC 配置
    if vmp.Spec.Console.VNC != nil && vmp.Spec.Console.VNC.Enabled {
        vnc := kubevirtv1.Graphics{
            Type:       "VNC",
            AutoAttach: true,
        }
        
        if vmp.Spec.Console.VNC.Port != nil {
            vnc.Port = vmp.Spec.Console.VNC.Port
        }
        
        if vmp.Spec.Console.VNC.ListenAddress != nil {
            vnc.Listen = &kubevirtv1.Listener{
                Address: *vmp.Spec.Console.VNC.ListenAddress,
                Type:    "address",
            }
        }
        
        graphics = append(graphics, vnc)
    }
    
    return graphics
}
```

### 3.3 VNC 访问实现

#### 方案一：使用 virtctl
```bash
# 通过 virtctl 访问 VNC
virtctl vnc <vm-name> -n <namespace>
```

#### 方案二：通过 Service 暴露
```go
// pkg/kubevirt/vnc_service.go

func CreateVNCService(ctx context.Context, c client.Client, vmName, namespace string) error {
    service := &corev1.Service{
        ObjectMeta: metav1.ObjectMeta{
            Name:      fmt.Sprintf("%s-vnc", vmName),
            Namespace: namespace,
        },
        Spec: corev1.ServiceSpec{
            Type: corev1.ServiceTypeNodePort,
            Selector: map[string]string{
                "kubevirt.io/vm": vmName,
            },
            Ports: []corev1.ServicePort{
                {
                    Name:       "vnc",
                    Port:       5900,
                    TargetPort: intstr.FromInt(5900),
                    Protocol:   corev1.ProtocolTCP,
                },
            },
        },
    }
    
    return c.Create(ctx, service)
}
```

## 4. API 设计

### 4.1 WukongSpec 扩展

```go
// api/v1alpha1/wukong_types.go

type WukongSpec struct {
    // ... 现有字段 ...
    
    // Console 控制台配置（可选）
    // +optional
    Console *ConsoleSpec `json:"console,omitempty"`
}

type ConsoleSpec struct {
    // VNC VNC 控制台配置
    // +optional
    VNC *VNCConfig `json:"vnc,omitempty"`
    
    // SPICE SPICE 控制台配置
    // +optional
    SPICE *SPICEConfig `json:"spice,omitempty"`
    
    // Serial 串行控制台配置
    // +optional
    Serial *SerialConfig `json:"serial,omitempty"`
}

type VNCConfig struct {
    // Enabled 是否启用 VNC
    Enabled bool `json:"enabled"`
    
    // Port VNC 端口（默认 5900）
    // +optional
    Port *int32 `json:"port,omitempty"`
    
    // ListenAddress 监听地址（默认 0.0.0.0）
    // +optional
    ListenAddress *string `json:"listenAddress,omitempty"`
    
    // TLS TLS 加密配置
    // +optional
    TLS *TLSConfig `json:"tls,omitempty"`
    
    // ServiceExposure Service 暴露配置
    // +optional
    ServiceExposure *VNCServiceExposureSpec `json:"serviceExposure,omitempty"`
}

type TLSConfig struct {
    // Enabled 是否启用 TLS
    Enabled bool `json:"enabled"`
    
    // SecretName TLS 证书 Secret 名称
    // +optional
    SecretName string `json:"secretName,omitempty"`
}
```

### 4.2 Controller 实现

```go
// internal/controller/wukong_controller.go

func (r *WukongReconciler) reconcileConsole(ctx context.Context, vmp *vmv1alpha1.Wukong) error {
    if vmp.Spec.Console == nil {
        return nil
    }
    
    vmName := fmt.Sprintf("%s-vm", vmp.Name)
    
    // 处理 VNC Service（如果需要）
    if vmp.Spec.Console.VNC != nil && 
       vmp.Spec.Console.VNC.Enabled &&
       vmp.Spec.Console.VNC.ServiceExposure != nil &&
       vmp.Spec.Console.VNC.ServiceExposure.Enabled {
        return r.reconcileVNCService(ctx, vmName, vmp)
    }
    
    return nil
}

func (r *WukongReconciler) reconcileVNCService(ctx context.Context, vmName string, vmp *vmv1alpha1.Wukong) error {
    serviceName := fmt.Sprintf("%s-vnc", vmName)
    service := &corev1.Service{}
    key := client.ObjectKey{Name: serviceName, Namespace: vmp.Namespace}
    
    if err := r.Get(ctx, key, service); err != nil {
        if errors.IsNotFound(err) {
            // 创建 VNC Service
            return kubevirt.CreateVNCService(ctx, r.Client, vmName, vmp.Namespace)
        }
        return err
    }
    
    // 更新 Service（如果需要）
    return nil
}
```

## 5. 使用示例

### 5.1 基本 VNC 配置
```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: vnc-vm
spec:
  cpu: 2
  memory: 4Gi
  console:
    vnc:
      enabled: true
```

### 5.2 带 Service 暴露的 VNC
```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: vnc-vm
spec:
  console:
    vnc:
      enabled: true
      port: 5900
      serviceExposure:
        enabled: true
        type: NodePort
        nodePort: 30900
```

### 5.3 带 TLS 的 VNC
```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: secure-vnc-vm
spec:
  console:
    vnc:
      enabled: true
      tls:
        enabled: true
        secretName: vnc-tls-cert
```

## 6. 访问方式

### 6.1 通过 virtctl
```bash
# 启动 VNC 代理
virtctl vnc <vm-name> -n <namespace>

# 或指定端口
virtctl vnc <vm-name> -n <namespace> --port 5900
```

### 6.2 通过 Service
```bash
# 获取 NodePort
kubectl get svc <vm-name>-vnc -n <namespace>

# 使用 VNC 客户端连接
vncviewer <node-ip>:<node-port>
```

### 6.3 通过 Web UI
- 使用 noVNC 等 Web VNC 客户端
- 通过 Ingress 暴露 VNC 服务
- 集成到管理平台

## 7. 注意事项

### 7.1 安全性
- 默认启用 TLS 加密
- 实现访问控制（RBAC）
- 记录访问日志
- 限制访问来源

### 7.2 性能
- VNC 需要网络带宽
- 考虑使用压缩
- 优化图像传输
- 监控连接性能

### 7.3 兼容性
- 确保 VM 内支持 VNC
- 检查客户端兼容性
- 处理不同 VNC 版本

## 8. 面试要点

### 8.1 如何实现 VNC 控制台？

**答案**:
- 在 VirtualMachineInstance 的 Devices 中配置 Graphics
- 使用 KubeVirt 的 VNC 支持
- 通过 virtctl 或 Service 暴露访问
- 配置 TLS 加密和访问控制

### 8.2 VNC 的安全考虑？

**答案**:
- 使用 TLS 加密连接
- 实现访问控制（RBAC）
- 记录访问日志
- 限制访问来源和端口

### 8.3 VNC 和 SSH 的区别？

**答案**:
- **VNC**: 图形界面，适合桌面应用，需要更多带宽
- **SSH**: 文本界面，适合命令行操作，带宽需求低

