# 空虚拟机与基于 PVC 创建 VM

## 1. 功能概述

### 1.1 空虚拟机
创建没有系统盘的 VM，仅包含数据盘。

**使用场景**:
- 特殊应用场景（如容器化应用）
- 临时计算节点
- 数据盘测试

### 1.2 基于 PVC 创建 VM
使用已有的 PVC 作为系统盘创建 VM。

**使用场景**:
- 从备份恢复 VM
- 复用已有磁盘
- 迁移 VM 到新集群

## 2. 当前实现状态

### 2.1 已实现
- ✅ 支持创建空 PVC（`disk.image` 为空）
- ✅ 支持基于 PVC 挂载（通过 `VolumeSource.PersistentVolumeClaim`）

### 2.2 待完善
- ⚠️ 空虚拟机场景（无系统盘）
- ⚠️ 明确指定使用已有 PVC
- ⚠️ PVC 验证和状态检查

## 3. 技术实现

### 3.1 空虚拟机实现

当前实现中，如果 `disk.image` 为空，会创建空 PVC。但 VirtualMachine 仍然需要一个系统盘。

**实现方案**:
```go
// pkg/kubevirt/vm.go

func buildVMSpec(ctx context.Context, c client.Client, vmp *vmv1alpha1.Wukong, ...) kubevirtv1.VirtualMachineSpec {
    // 检查是否有系统盘
    hasSystemDisk := false
    for _, vol := range volumes {
        if vol.Name == "system" || vol.Name == vmp.Spec.Disks[0].Name {
            hasSystemDisk = true
            break
        }
    }
    
    // 如果没有系统盘，创建一个最小的空盘
    if !hasSystemDisk {
        // 创建最小空 PVC 或使用 ephemeral disk
        volumes = append(volumes, vmv1alpha1.VolumeStatus{
            Name:    "system",
            PVCName: "empty-system-disk",
            Bound:   true,
            Size:    "1Gi",
        })
    }
    
    // ... 构建 VM spec
}
```

### 3.2 基于已有 PVC 创建

**实现方案**:
```go
// api/v1alpha1/wukong_types.go

type DiskConfig struct {
    // ... 现有字段 ...
    
    // ExistingPVC 使用已有 PVC（可选）
    // +optional
    ExistingPVC *ExistingPVCSpec `json:"existingPVC,omitempty"`
}

type ExistingPVCSpec struct {
    // Name PVC 名称
    Name string `json:"name"`
    
    // Namespace PVC 命名空间（可选，默认同 Wukong）
    // +optional
    Namespace string `json:"namespace,omitempty"`
    
    // ReadOnly 是否只读挂载
    // +optional
    ReadOnly bool `json:"readOnly,omitempty"`
}
```

## 4. API 设计

### 4.1 空虚拟机配置

```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: empty-vm
spec:
  cpu: 2
  memory: 4Gi
  disks:
  # 不指定系统盘，或指定空系统盘
  - name: system
    size: 1Gi
    # image 为空，创建空 PVC
  - name: data
    size: 100Gi
    # 数据盘
```

### 4.2 基于已有 PVC 配置

```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: vm-from-pvc
spec:
  cpu: 2
  memory: 4Gi
  disks:
  - name: system
    existingPVC:
      name: existing-disk-pvc
      namespace: default
      readOnly: false
```

## 5. Controller 实现

### 5.1 处理已有 PVC

```go
// pkg/storage/reconcile.go

func ReconcileDisks(ctx context.Context, c client.Client, vmp *vmv1alpha1.Wukong) ([]vmv1alpha1.VolumeStatus, error) {
    volumesStatus := make([]vmv1alpha1.VolumeStatus, 0, len(vmp.Spec.Disks))
    
    for _, disk := range vmp.Spec.Disks {
        var pvcName string
        var bound bool
        var err error
        
        // 优先检查是否使用已有 PVC
        if disk.ExistingPVC != nil {
            pvcName, bound, err = ReconcileExistingPVC(ctx, c, disk, vmp.Namespace)
        } else if disk.Image != "" {
            // 使用 DataVolume 导入
            pvcName, bound, err = ReconcileDataVolume(ctx, c, disk, vmp.Namespace, vmp.Name)
        } else {
            // 创建空 PVC
            pvcName, bound, err = ReconcilePVC(ctx, c, disk, vmp.Namespace, vmp.Name)
        }
        
        // ... 处理结果
    }
    
    return volumesStatus, nil
}

func ReconcileExistingPVC(ctx context.Context, c client.Client, disk DiskConfig, namespace string) (string, bool, error) {
    pvcName := disk.ExistingPVC.Name
    pvcNamespace := disk.ExistingPVC.Namespace
    if pvcNamespace == "" {
        pvcNamespace = namespace
    }
    
    // 验证 PVC 是否存在
    pvc := &corev1.PersistentVolumeClaim{}
    key := client.ObjectKey{Name: pvcName, Namespace: pvcNamespace}
    if err := c.Get(ctx, key, pvc); err != nil {
        return "", false, fmt.Errorf("PVC not found: %s/%s", pvcNamespace, pvcName)
    }
    
    // 检查 PVC 状态
    bound := pvc.Status.Phase == corev1.ClaimBound
    
    return pvcName, bound, nil
}
```

### 5.2 空虚拟机处理

```go
// pkg/kubevirt/vm.go

func buildDisks(volumes []vmv1alpha1.VolumeStatus) []kubevirtv1.Disk {
    disks := make([]kubevirtv1.Disk, 0, len(volumes))
    
    for _, vol := range volumes {
        // 跳过空系统盘（如果配置了）
        if vol.Name == "system" && vol.Size == "1Gi" && vol.PVCName == "empty-system-disk" {
            // 使用 ephemeral disk 或最小系统盘
            continue
        }
        
        disk := kubevirtv1.Disk{
            Name: vol.Name,
            DiskDevice: kubevirtv1.DiskDevice{
                Disk: &kubevirtv1.DiskTarget{
                    Bus: "virtio",
                },
            },
        }
        disks = append(disks, disk)
    }
    
    return disks
}
```

## 6. 使用示例

### 6.1 创建空虚拟机
```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: empty-vm
spec:
  cpu: 2
  memory: 4Gi
  disks:
  # 最小系统盘（可选）
  - name: system
    size: 1Gi
  # 数据盘
  - name: data1
    size: 50Gi
  - name: data2
    size: 100Gi
```

### 6.2 基于已有 PVC 创建
```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: restored-vm
spec:
  cpu: 2
  memory: 4Gi
  disks:
  - name: system
    existingPVC:
      name: backup-disk-pvc
      namespace: backups
  - name: data
    size: 100Gi
```

### 6.3 混合使用
```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: hybrid-vm
spec:
  cpu: 2
  memory: 4Gi
  disks:
  # 从镜像创建系统盘
  - name: system
    size: 20Gi
    image: docker://quay.io/kubevirt/ubuntu:22.04
  # 使用已有数据盘
  - name: data
    existingPVC:
      name: existing-data-pvc
  # 创建新数据盘
  - name: cache
    size: 50Gi
```

## 7. 验证和错误处理

### 7.1 PVC 验证

```go
func validateExistingPVC(ctx context.Context, c client.Client, disk DiskConfig, namespace string) error {
    pvcName := disk.ExistingPVC.Name
    pvcNamespace := disk.ExistingPVC.Namespace
    if pvcNamespace == "" {
        pvcNamespace = namespace
    }
    
    // 检查 PVC 是否存在
    pvc := &corev1.PersistentVolumeClaim{}
    key := client.ObjectKey{Name: pvcName, Namespace: pvcNamespace}
    if err := c.Get(ctx, key, pvc); err != nil {
        return fmt.Errorf("PVC %s/%s not found: %w", pvcNamespace, pvcName, err)
    }
    
    // 检查 PVC 状态
    if pvc.Status.Phase != corev1.ClaimBound {
        return fmt.Errorf("PVC %s/%s is not bound (phase: %s)", pvcNamespace, pvcName, pvc.Status.Phase)
    }
    
    // 检查访问模式
    if len(pvc.Spec.AccessModes) == 0 || pvc.Spec.AccessModes[0] != corev1.ReadWriteOnce {
        return fmt.Errorf("PVC %s/%s access mode not supported (requires ReadWriteOnce)", pvcNamespace, pvcName)
    }
    
    return nil
}
```

## 8. 注意事项

### 8.1 空虚拟机限制
- 某些应用可能需要系统盘
- 需要明确文档说明使用场景
- 考虑使用最小系统盘（1Gi）

### 8.2 已有 PVC 使用
- 确保 PVC 可访问（同命名空间或跨命名空间）
- 检查 PVC 状态（Bound）
- 注意 PVC 的访问模式（ReadWriteOnce）
- 防止多个 VM 同时使用同一 PVC（除非只读）

### 8.3 数据安全
- 使用已有 PVC 时注意数据保护
- 支持只读挂载选项
- 提供数据备份建议

## 9. 面试要点

### 9.1 为什么需要空虚拟机？

**答案**:
- 某些特殊应用场景不需要系统盘
- 容器化应用可能只需要数据盘
- 临时计算节点场景
- 测试和开发环境

### 9.2 基于已有 PVC 创建 VM 的使用场景？

**答案**:
- 从备份恢复 VM
- 迁移 VM 到新集群
- 复用已有磁盘数据
- 快速部署相同配置的 VM

### 9.3 如何防止多个 VM 同时使用同一 PVC？

**答案**:
- 检查 PVC 的访问模式（ReadWriteOnce 只能一个 Pod 使用）
- 使用只读挂载（readOnly: true）
- 实现 PVC 使用状态跟踪
- 提供警告信息

