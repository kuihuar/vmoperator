# CPU 和内存扩缩容

## 1. 功能概述

### 1.1 CPU 扩缩容
动态调整 VM 的 CPU 核心数，支持扩容和缩容。

**使用场景**:
- 业务高峰期增加 CPU
- 低峰期减少 CPU 节省成本
- 性能调优
- 资源重新分配

### 1.2 内存扩缩容
动态调整 VM 的内存大小，支持扩容和缩容。

**使用场景**:
- 内存不足时扩容
- 内存富余时缩容
- 应用内存需求变化
- 资源优化

## 2. 当前实现状态

### 2.1 已实现
- ✅ **静态配置**: 创建时配置 CPU 和内存
- ✅ **更新支持**: 修改 Spec 可以更新（但需要重启 VM）

### 2.2 待实现
- ❌ **热扩容**: 运行时扩容无需重启
- ❌ **热缩容**: 运行时缩容无需重启
- ❌ **扩容验证**: 验证扩容是否成功
- ❌ **扩容策略**: 自动扩容策略

## 3. 技术实现

### 3.1 KubeVirt 支持

KubeVirt 支持 CPU 和内存热扩容，但需要：
- VM 内安装 QEMU Guest Agent
- 操作系统支持热插拔 CPU/内存
- 足够的节点资源

### 3.2 实现方案

#### 方案一：直接更新 VirtualMachine（冷扩容）
```go
// pkg/kubevirt/scaling.go

func ScaleCPU(ctx context.Context, c client.Client, vmName, namespace string, newCPU int) error {
    vm := &kubevirtv1.VirtualMachine{}
    key := client.ObjectKey{Name: vmName, Namespace: namespace}
    if err := c.Get(ctx, key, vm); err != nil {
        return err
    }
    
    // 更新 CPU
    if vm.Spec.Template.Spec.Domain.CPU == nil {
        vm.Spec.Template.Spec.Domain.CPU = &kubevirtv1.CPU{}
    }
    vm.Spec.Template.Spec.Domain.CPU.Cores = uint32(newCPU)
    
    // 设置 running 为 false，需要重启
    running := false
    vm.Spec.Running = &running
    
    return c.Update(ctx, vm)
}
```

#### 方案二：热扩容（直接更新 VMI）
```go
// pkg/kubevirt/scaling.go

func ScaleCPUHot(ctx context.Context, c client.Client, vmName, namespace string, newCPU int) error {
    // 1. 获取 VMI
    vmi := &kubevirtv1.VirtualMachineInstance{}
    key := client.ObjectKey{Name: vmName, Namespace: namespace}
    if err := c.Get(ctx, key, vmi); err != nil {
        return fmt.Errorf("VMI not found: %w", err)
    }
    
    // 2. 检查是否支持热扩容
    if !supportsHotPlug(vmi) {
        return fmt.Errorf("VM does not support hot plug CPU")
    }
    
    // 3. 更新 CPU（热扩容）
    if vmi.Spec.Domain.CPU == nil {
        vmi.Spec.Domain.CPU = &kubevirtv1.CPU{}
    }
    oldCPU := vmi.Spec.Domain.CPU.Cores
    vmi.Spec.Domain.CPU.Cores = uint32(newCPU)
    
    // 4. 更新 VMI
    if err := c.Update(ctx, vmi); err != nil {
        return fmt.Errorf("failed to update VMI: %w", err)
    }
    
    // 5. 等待 CPU 生效（通过 QEMU Guest Agent 查询）
    return waitForCPUUpdated(ctx, c, vmName, namespace, oldCPU, uint32(newCPU))
}

func ScaleMemoryHot(ctx context.Context, c client.Client, vmName, namespace string, newMemory string) error {
    // 1. 获取 VMI
    vmi := &kubevirtv1.VirtualMachineInstance{}
    key := client.ObjectKey{Name: vmName, Namespace: namespace}
    if err := c.Get(ctx, key, vmi); err != nil {
        return fmt.Errorf("VMI not found: %w", err)
    }
    
    // 2. 检查是否支持热扩容
    if !supportsHotPlug(vmi) {
        return fmt.Errorf("VM does not support hot plug memory")
    }
    
    // 3. 解析新内存
    memoryQuantity, err := resource.ParseQuantity(newMemory)
    if err != nil {
        return fmt.Errorf("invalid memory format: %w", err)
    }
    
    // 4. 更新内存（热扩容）
    if vmi.Spec.Domain.Memory == nil {
        vmi.Spec.Domain.Memory = &kubevirtv1.Memory{}
    }
    vmi.Spec.Domain.Memory.Guest = &memoryQuantity
    
    // 5. 更新 VMI
    if err := c.Update(ctx, vmi); err != nil {
        return fmt.Errorf("failed to update VMI: %w", err)
    }
    
    // 6. 等待内存生效
    return waitForMemoryUpdated(ctx, c, vmName, namespace, newMemory)
}

func supportsHotPlug(vmi *kubevirtv1.VirtualMachineInstance) bool {
    // 检查是否有 QEMU Guest Agent
    if vmi.Status.Conditions != nil {
        for _, condition := range vmi.Status.Conditions {
            if condition.Type == kubevirtv1.VirtualMachineInstanceAgentConditionType &&
               condition.Status == corev1.ConditionTrue {
                return true
            }
        }
    }
    return false
}
```

### 3.3 Controller 实现

```go
// internal/controller/wukong_controller.go

func (r *WukongReconciler) reconcileScaling(ctx context.Context, vmp *vmv1alpha1.Wukong) error {
    logger := log.FromContext(ctx)
    vmName := fmt.Sprintf("%s-vm", vmp.Name)
    
    // 1. 获取当前 VirtualMachine
    vm := &kubevirtv1.VirtualMachine{}
    key := client.ObjectKey{Name: vmName, Namespace: vmp.Namespace}
    if err := r.Get(ctx, key, vm); err != nil {
        return err
    }
    
    // 2. 检查 CPU 是否需要更新
    currentCPU := int(vm.Spec.Template.Spec.Domain.CPU.Cores)
    desiredCPU := vmp.Spec.CPU
    if currentCPU != desiredCPU {
        logger.Info("CPU scaling detected", "current", currentCPU, "desired", desiredCPU)
        
        // 尝试热扩容
        if err := r.scaleCPU(ctx, vmName, vmp, currentCPU, desiredCPU); err != nil {
            logger.Error(err, "hot CPU scaling failed, will use cold scaling")
            // 降级为冷扩容（需要重启）
            return r.scaleCPUCold(ctx, vm, desiredCPU)
        }
    }
    
    // 3. 检查内存是否需要更新
    currentMemory := vm.Spec.Template.Spec.Domain.Memory.Guest.String()
    desiredMemory := vmp.Spec.Memory
    if currentMemory != desiredMemory {
        logger.Info("Memory scaling detected", "current", currentMemory, "desired", desiredMemory)
        
        // 尝试热扩容
        if err := r.scaleMemory(ctx, vmName, vmp, currentMemory, desiredMemory); err != nil {
            logger.Error(err, "hot memory scaling failed, will use cold scaling")
            // 降级为冷扩容（需要重启）
            return r.scaleMemoryCold(ctx, vm, desiredMemory)
        }
    }
    
    return nil
}

func (r *WukongReconciler) scaleCPU(ctx context.Context, vmName string, vmp *vmv1alpha1.Wukong, oldCPU, newCPU int) error {
    // 检查是否支持热扩容
    vmi := &kubevirtv1.VirtualMachineInstance{}
    key := client.ObjectKey{Name: vmName, Namespace: vmp.Namespace}
    if err := r.Get(ctx, key, vmi); err != nil {
        // VMI 不存在，使用冷扩容
        return fmt.Errorf("VMI not found")
    }
    
    // 尝试热扩容
    if err := kubevirt.ScaleCPUHot(ctx, r.Client, vmName, vmp.Namespace, newCPU); err != nil {
        return err
    }
    
    // 更新状态
    vmp.Status.ScalingStatus = &vmv1alpha1.ScalingStatus{
        CPU: &vmv1alpha1.ResourceScalingStatus{
            Current:  oldCPU,
            Desired:  newCPU,
            Phase:    "Scaling",
            HotPlug:  true,
        },
    }
    r.Status().Update(ctx, vmp)
    
    return nil
}
```

## 4. API 设计

### 4.1 WukongSpec 扩展

```go
// api/v1alpha1/wukong_types.go

type WukongSpec struct {
    // ... 现有字段 ...
    
    // ScalingPolicy 扩容策略（可选）
    // +optional
    ScalingPolicy *ScalingPolicySpec `json:"scalingPolicy,omitempty"`
}

type ScalingPolicySpec struct {
    // EnableHotPlug 是否启用热扩容
    // +optional
    EnableHotPlug bool `json:"enableHotPlug,omitempty"`
    
    // MinCPU 最小 CPU（用于缩容限制）
    // +optional
    MinCPU *int `json:"minCPU,omitempty"`
    
    // MaxCPU 最大 CPU（用于扩容限制）
    // +optional
    MaxCPU *int `json:"maxCPU,omitempty"`
    
    // MinMemory 最小内存
    // +optional
    MinMemory *string `json:"minMemory,omitempty"`
    
    // MaxMemory 最大内存
    // +optional
    MaxMemory *string `json:"maxMemory,omitempty"`
}
```

### 4.2 Status 扩展

```go
// api/v1alpha1/wukong_types.go

type WukongStatus struct {
    // ... 现有字段 ...
    
    // ScalingStatus 扩容状态
    // +optional
    ScalingStatus *ScalingStatus `json:"scalingStatus,omitempty"`
}

type ScalingStatus struct {
    // CPU CPU 扩容状态
    // +optional
    CPU *ResourceScalingStatus `json:"cpu,omitempty"`
    
    // Memory 内存扩容状态
    // +optional
    Memory *ResourceScalingStatus `json:"memory,omitempty"`
}

type ResourceScalingStatus struct {
    Current int    `json:"current"`
    Desired int    `json:"desired"`
    Phase   string `json:"phase"` // Scaling, Succeeded, Failed
    HotPlug bool   `json:"hotPlug,omitempty"`
    Message string `json:"message,omitempty"`
}
```

## 5. 使用示例

### 5.1 CPU 扩容
```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: my-vm
spec:
  cpu: 4  # 从 2 扩容到 4
  memory: 8Gi
  scalingPolicy:
    enableHotPlug: true
    minCPU: 1
    maxCPU: 8
```

### 5.2 内存扩容
```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: my-vm
spec:
  cpu: 2
  memory: 16Gi  # 从 8Gi 扩容到 16Gi
  scalingPolicy:
    enableHotPlug: true
    minMemory: "2Gi"
    maxMemory: "32Gi"
```

### 5.3 CPU 缩容
```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: my-vm
spec:
  cpu: 2  # 从 4 缩容到 2
  memory: 8Gi
  scalingPolicy:
    enableHotPlug: true
    minCPU: 1
```

## 6. 注意事项

### 6.1 热扩容限制
- 需要 VM 内安装 QEMU Guest Agent
- 需要操作系统支持（Linux 通常支持）
- 某些资源可能不支持热扩容
- 需要足够的节点资源

### 6.2 缩容风险
- 缩容可能导致性能下降
- 需要确保应用可以适应
- 建议先监控资源使用情况
- 提供回滚机制

### 6.3 验证扩容
- 通过 QEMU Guest Agent 查询实际资源
- 验证扩容是否成功
- 记录扩容历史
- 提供状态查询接口

## 7. 面试要点

### 7.1 热扩容和冷扩容的区别？

**答案**:
- **热扩容**: 无需重启，业务不中断，需要操作系统和 QEMU Guest Agent 支持
- **冷扩容**: 需要重启 VM，业务中断，但所有系统都支持

### 7.2 如何实现 CPU 热扩容？

**答案**:
- 直接更新 VirtualMachineInstance 的 CPU 配置
- KubeVirt 通过 QEMU 热插拔 CPU
- 需要 VM 内操作系统支持
- 通过 QEMU Guest Agent 验证扩容结果

### 7.3 内存热扩容的限制？

**答案**:
- 只能扩容，不能缩容（内存热插拔限制）
- 需要足够的节点内存
- 需要操作系统支持内存热插拔
- 某些内存配置可能不支持

