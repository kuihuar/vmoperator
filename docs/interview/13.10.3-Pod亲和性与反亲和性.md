# Pod 亲和性与反亲和性

## 1. 功能概述

### 1.1 Pod 亲和性
控制 VM 与其他 Pod/VM 一起调度，基于标签和拓扑域。

**使用场景**:
- 将相关服务调度到一起（降低延迟）
- 将 VM 调度到有特定服务的节点
- 实现服务亲和性

### 1.2 Pod 反亲和性
控制 VM 与其他 Pod/VM 分开调度，基于标签和拓扑域。

**使用场景**:
- 高可用部署（分散到不同节点）
- 避免资源竞争
- 故障隔离

## 2. 当前实现状态

### 2.1 已实现
- ✅ **简单反亲和性**: 通过 `HighAvailability.AntiAffinity` 支持（简单布尔值，防止同一节点）

### 2.2 待实现
- ❌ **完整 Pod 亲和性**: 支持完整的 Pod 亲和性配置
- ❌ **完整 Pod 反亲和性**: 支持完整的 Pod 反亲和性配置
- ❌ **拓扑域支持**: 支持不同的拓扑域（节点、区域等）

## 3. 技术实现

### 3.1 当前实现

```go
// api/v1alpha1/wukong_types.go

type HighAvailabilitySpec struct {
    // AntiAffinity 反亲和性（简单布尔值）
    AntiAffinity bool `json:"antiAffinity,omitempty"`
}
```

当前实现只是简单的布尔值，在构建 VM 时添加基本的 Pod 反亲和性。

### 3.2 扩展实现

```go
// api/v1alpha1/wukong_types.go

type SchedulingSpec struct {
    // ... 现有字段 ...
    
    // PodAffinity Pod 亲和性
    // +optional
    PodAffinity *PodAffinitySpec `json:"podAffinity,omitempty"`
    
    // PodAntiAffinity Pod 反亲和性
    // +optional
    PodAntiAffinity *PodAntiAffinitySpec `json:"podAntiAffinity,omitempty"`
}

type PodAffinitySpec struct {
    // Required 必须满足的 Pod 选择条件
    // +optional
    Required []PodAffinityTermSpec `json:"required,omitempty"`
    
    // Preferred 优先满足的 Pod 选择条件
    // +optional
    Preferred []WeightedPodAffinityTermSpec `json:"preferred,omitempty"`
}

type PodAntiAffinitySpec struct {
    // Required 必须满足的 Pod 选择条件
    // +optional
    Required []PodAffinityTermSpec `json:"required,omitempty"`
    
    // Preferred 优先满足的 Pod 选择条件
    // +optional
    Preferred []WeightedPodAffinityTermSpec `json:"preferred,omitempty"`
}

type PodAffinityTermSpec struct {
    // LabelSelector Pod 标签选择器
    // +optional
    LabelSelector *metav1.LabelSelector `json:"labelSelector,omitempty"`
    
    // NamespaceSelector 命名空间选择器
    // +optional
    NamespaceSelector *metav1.LabelSelector `json:"namespaceSelector,omitempty"`
    
    // Namespaces 命名空间列表（如果 NamespaceSelector 为空）
    // +optional
    Namespaces []string `json:"namespaces,omitempty"`
    
    // TopologyKey 拓扑域键（如 kubernetes.io/hostname）
    TopologyKey string `json:"topologyKey"`
}

type WeightedPodAffinityTermSpec struct {
    // Weight 权重（1-100）
    Weight int32 `json:"weight"`
    
    // PodAffinityTerm Pod 亲和性条件
    PodAffinityTerm PodAffinityTermSpec `json:"podAffinityTerm"`
}
```

### 3.3 Controller 实现

```go
// pkg/kubevirt/scheduling.go

func buildPodAffinity(vmp *vmv1alpha1.Wukong) (*corev1.PodAffinity, *corev1.PodAntiAffinity) {
    var podAffinity *corev1.PodAffinity
    var podAntiAffinity *corev1.PodAntiAffinity
    
    if vmp.Spec.Scheduling == nil {
        // 向后兼容：检查 HighAvailability.AntiAffinity
        if vmp.Spec.HighAvailability != nil && vmp.Spec.HighAvailability.AntiAffinity {
            podAntiAffinity = buildSimpleAntiAffinity(vmp)
        }
        return podAffinity, podAntiAffinity
    }
    
    // 构建 Pod 亲和性
    if vmp.Spec.Scheduling.PodAffinity != nil {
        podAffinity = buildPodAffinityFromSpec(vmp.Spec.Scheduling.PodAffinity)
    }
    
    // 构建 Pod 反亲和性
    if vmp.Spec.Scheduling.PodAntiAffinity != nil {
        podAntiAffinity = buildPodAntiAffinityFromSpec(vmp.Spec.Scheduling.PodAntiAffinity)
    } else if vmp.Spec.HighAvailability != nil && vmp.Spec.HighAvailability.AntiAffinity {
        // 向后兼容
        podAntiAffinity = buildSimpleAntiAffinity(vmp)
    }
    
    return podAffinity, podAntiAffinity
}

func buildSimpleAntiAffinity(vmp *vmv1alpha1.Wukong) *corev1.PodAntiAffinity {
    return &corev1.PodAntiAffinity{
        RequiredDuringSchedulingIgnoredDuringExecution: []corev1.PodAffinityTerm{
            {
                LabelSelector: &metav1.LabelSelector{
                    MatchLabels: map[string]string{
                        "wukong.novasphere.dev/name": vmp.Name,
                    },
                },
                TopologyKey: "kubernetes.io/hostname",
            },
        },
    }
}

func buildPodAffinityFromSpec(spec *vmv1alpha1.PodAffinitySpec) *corev1.PodAffinity {
    affinity := &corev1.PodAffinity{}
    
    // Required 条件
    if len(spec.Required) > 0 {
        terms := make([]corev1.PodAffinityTerm, 0, len(spec.Required))
        for _, term := range spec.Required {
            terms = append(terms, buildPodAffinityTerm(term))
        }
        affinity.RequiredDuringSchedulingIgnoredDuringExecution = terms
    }
    
    // Preferred 条件
    if len(spec.Preferred) > 0 {
        weightedTerms := make([]corev1.WeightedPodAffinityTerm, 0, len(spec.Preferred))
        for _, weighted := range spec.Preferred {
            weightedTerms = append(weightedTerms, corev1.WeightedPodAffinityTerm{
                Weight:          weighted.Weight,
                PodAffinityTerm: buildPodAffinityTerm(weighted.PodAffinityTerm),
            })
        }
        affinity.PreferredDuringSchedulingIgnoredDuringExecution = weightedTerms
    }
    
    return affinity
}

func buildPodAffinityTerm(term vmv1alpha1.PodAffinityTermSpec) corev1.PodAffinityTerm {
    podTerm := corev1.PodAffinityTerm{
        TopologyKey: term.TopologyKey,
    }
    
    if term.LabelSelector != nil {
        podTerm.LabelSelector = term.LabelSelector
    }
    
    if term.NamespaceSelector != nil {
        podTerm.NamespaceSelector = term.NamespaceSelector
    }
    
    if len(term.Namespaces) > 0 {
        podTerm.Namespaces = term.Namespaces
    }
    
    return podTerm
}
```

## 4. API 设计

### 4.1 使用示例

#### 基本 Pod 反亲和性（高可用）
```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: ha-vm
spec:
  cpu: 2
  memory: 4Gi
  scheduling:
    podAntiAffinity:
      required:
      - labelSelector:
          matchLabels:
            app: my-app
        topologyKey: kubernetes.io/hostname
```

#### Pod 亲和性（服务亲和）
```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: app-vm
spec:
  scheduling:
    podAffinity:
      preferred:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchLabels:
              app: database
          topologyKey: kubernetes.io/hostname
```

#### 跨命名空间反亲和性
```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: isolated-vm
spec:
  scheduling:
    podAntiAffinity:
      required:
      - labelSelector:
          matchLabels:
            app: competitor
        namespaceSelector:
          matchLabels:
            env: production
        topologyKey: kubernetes.io/hostname
```

#### 区域级别反亲和性
```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: multi-zone-vm
spec:
  scheduling:
    podAntiAffinity:
      required:
      - labelSelector:
          matchLabels:
            app: my-app
        topologyKey: topology.kubernetes.io/zone
```

## 5. 拓扑域（TopologyKey）

### 5.1 常用拓扑域
- **kubernetes.io/hostname**: 节点级别
- **topology.kubernetes.io/zone**: 可用区级别
- **topology.kubernetes.io/region**: 区域级别
- **自定义拓扑域**: 根据需求定义

### 5.2 拓扑域选择
- **节点级别**: 确保不同节点（高可用）
- **区域级别**: 确保不同区域（容灾）
- **自定义**: 根据业务需求

## 6. 注意事项

### 6.1 调度约束
- Required 条件必须满足，否则无法调度
- Preferred 条件尽量满足，但不强制
- 过多的约束可能导致无法调度

### 6.2 性能影响
- Pod 亲和性规则可能影响调度性能
- 需要合理配置选择器
- 避免过于复杂的规则

### 6.3 标签管理
- 确保 Pod/VM 有正确的标签
- 使用一致的标签命名规范
- 定期审查标签使用

## 7. 面试要点

### 7.1 Pod 亲和性和节点亲和性的区别？

**答案**:
- **节点亲和性**: 基于节点属性（标签、字段）调度
- **Pod 亲和性**: 基于其他 Pod/VM 的位置调度
- **拓扑域**: Pod 亲和性需要考虑拓扑域（节点、区域等）

### 7.2 如何实现高可用部署？

**答案**:
- 使用 Pod 反亲和性，确保 VM 分布在不同节点
- 使用 `kubernetes.io/hostname` 作为拓扑域
- 配置多个副本
- 结合健康检查确保服务可用

### 7.3 拓扑域的作用？

**答案**:
- 定义亲和性/反亲和性的作用范围
- 节点级别：确保不同节点
- 区域级别：确保不同区域
- 根据业务需求选择合适的拓扑域

