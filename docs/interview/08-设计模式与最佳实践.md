# 设计模式与最佳实践

## 1. Operator 模式

### 1.1 核心思想

**声明式管理**: 用户声明期望状态，Controller 负责实现

```
用户定义期望状态 (Spec)
    ↓
Controller 持续监控
    ↓
对比期望状态和实际状态
    ↓
执行操作使实际状态接近期望状态
    ↓
更新实际状态 (Status)
```

### 1.2 Reconcile 循环

```go
func (r *WukongReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
    // 1. 获取资源
    // 2. 检查删除
    // 3. 处理 Finalizer
    // 4. 验证 Spec
    // 5. 协调资源（网络、存储、VM）
    // 6. 同步状态
    // 7. 返回结果
}
```

## 2. 设计原则

### 2.1 幂等性

**原则**: 多次执行相同操作，结果应该相同

```go
// ✅ 好的实现：检查资源是否存在
existingVM := &kubevirtv1.VirtualMachine{}
err := c.Get(ctx, key, existingVM)
if errors.IsNotFound(err) {
    // 不存在才创建
    c.Create(ctx, vm)
} else {
    // 存在则更新
    c.Update(ctx, existingVM)
}
```

### 2.2 非阻塞

**原则**: Reconcile 循环应该是非阻塞的

```go
// ✅ 好的实现：不等待，通过 requeue 检查
logger.Info("PVC created, will check status in next reconcile")
return ctrl.Result{RequeueAfter: time.Second * 10}, nil

// ❌ 不好的实现：阻塞等待
time.Sleep(30 * time.Second)  // 不要这样做
```

### 2.3 错误恢复

**原则**: 错误时应该重试，而不是立即失败

```go
if err != nil {
    logger.Error(err, "failed to reconcile")
    // 设置错误状态
    vmp.Status.Phase = vmv1alpha1.PhaseError
    r.Status().Update(ctx, &vmp)
    // 延迟重试
    return ctrl.Result{RequeueAfter: time.Second * 30}, err
}
```

## 3. Finalizer 模式

### 3.1 作用

确保资源删除前完成清理工作

### 3.2 实现

```go
// 添加 Finalizer
if !containsString(vmp.Finalizers, finalizerName) {
    vmp.Finalizers = append(vmp.Finalizers, finalizerName)
    r.Update(ctx, &vmp)
    return ctrl.Result{Requeue: true}, nil
}

// 处理删除
if !vmp.DeletionTimestamp.IsZero() {
    // 执行清理逻辑
    // ...
    // 移除 Finalizer
    vmp.Finalizers = removeString(vmp.Finalizers, finalizerName)
    r.Update(ctx, &vmp)
}
```

## 4. OwnerReference 模式

### 4.1 作用

建立资源的所有权关系，实现级联删除

### 4.2 实现

```go
vm.OwnerReferences = []metav1.OwnerReference{
    {
        APIVersion: vmp.APIVersion,
        Kind:       vmp.Kind,
        Name:       vmp.Name,
        UID:        vmp.UID,
        Controller: &controller,
    },
}
```

**好处**:
- 删除 Wukong 时自动删除 VM
- 明确资源关系
- 符合 Kubernetes 最佳实践

## 5. 状态管理

### 5.1 Phase 状态机

```
Pending → Creating → Running
              ↓
          Stopped/Error
```

### 5.2 Conditions 机制

```go
conditions := []metav1.Condition{
    {
        Type:    "Ready",
        Status:  metav1.ConditionTrue,
        Reason:  "VMRunning",
        Message: "Virtual machine is running",
    },
    {
        Type:    "NetworksConfigured",
        Status:  metav1.ConditionTrue,
        Reason:  "NetworksReady",
        Message: "2 networks configured",
    },
}
```

## 6. Context 处理

### 6.1 Context 取消检查

```go
if ctx.Err() != nil {
    logger.V(1).Info("Context canceled, will retry")
    return ctrl.Result{RequeueAfter: time.Second * 10}, ctx.Err()
}
```

### 6.2 超时处理

```go
// 使用带超时的 Context
ctx, cancel := context.WithTimeout(ctx, 30*time.Second)
defer cancel()
```

## 7. 错误处理

### 7.1 错误分类

```go
if errors.IsNotFound(err) {
    // 资源不存在，创建新的
} else if ctx.Err() != nil {
    // Context 取消，重试
} else {
    // 其他错误，记录并重试
}
```

### 7.2 错误恢复策略

```go
// 临时错误：延迟重试
return ctrl.Result{RequeueAfter: time.Second * 30}, err

// 永久错误：设置错误状态
vmp.Status.Phase = vmv1alpha1.PhaseError
r.Status().Update(ctx, &vmp)
return ctrl.Result{}, nil
```

## 8. Requeue 策略

### 8.1 立即 Requeue

```go
return ctrl.Result{Requeue: true}, nil
```

**场景**: 添加 Finalizer 后

### 8.2 延迟 Requeue

```go
return ctrl.Result{RequeueAfter: time.Second * 10}, nil
```

**场景**: 等待资源就绪

### 8.3 不 Requeue

```go
return ctrl.Result{}, nil
```

**场景**: 状态已同步完成

## 9. 模块化设计

### 9.1 功能分离

```
pkg/
├── kubevirt/    # KubeVirt 集成
├── network/     # 网络管理
└── storage/     # 存储管理
```

### 9.2 接口设计

```go
// 每个模块提供独立的 Reconcile 函数
func ReconcileNetworks(ctx, client, wukong) ([]NetworkStatus, error)
func ReconcileDisks(ctx, client, wukong) ([]VolumeStatus, error)
func ReconcileVirtualMachine(ctx, client, wukong, networks, volumes) (string, error)
```

## 10. 最佳实践总结

### 10.1 代码组织

- ✅ 模块化设计，功能分离
- ✅ 每个模块提供独立的 Reconcile 函数
- ✅ 使用接口而非直接依赖

### 10.2 错误处理

- ✅ 检查 Context 取消
- ✅ 区分临时错误和永久错误
- ✅ 提供清晰的错误信息

### 10.3 状态管理

- ✅ 及时更新状态
- ✅ 使用 Conditions 提供详细信息
- ✅ 状态应该是可观察的

### 10.4 资源管理

- ✅ 使用 OwnerReference 建立关系
- ✅ 使用 Finalizer 确保清理
- ✅ 避免资源泄漏

## 11. 面试要点

### 11.1 Operator 模式的核心思想？

**答案**: 声明式管理，用户声明期望状态，Controller 负责实现

### 11.2 如何保证幂等性？

**答案**:
- 操作前检查资源是否存在
- 使用 Get-Create-Update 模式
- 避免重复操作

### 11.3 Finalizer 的作用？

**答案**:
- 确保资源删除前完成清理
- 防止资源泄漏
- 保证数据一致性

### 11.4 如何设计可扩展的 Operator？

**答案**:
- 模块化设计
- 功能分离
- 使用接口而非直接依赖
- 提供清晰的扩展点

