# 运行态克隆（VMIS）功能规划

## 1. 功能概述

### 1.1 运行态克隆
基于运行中的 VirtualMachineInstance (VMI) 创建新的 VM，无需停止源 VM。

**使用场景**:
- 零停机克隆运行中的 VM
- 快速创建测试环境
- 负载均衡场景
- 故障转移准备

### 1.2 技术特点
- **无停机**: 源 VM 继续运行
- **数据一致性**: 基于快照确保数据一致性
- **高性能**: 利用存储后端快照功能
- **高级特性**: 需要存储后端和 KubeVirt 支持

## 2. 当前实现状态

### 2.1 已实现
- ❌ 无运行态克隆功能

### 2.2 待实现
- ❌ 基于 VMI 创建快照
- ❌ 基于快照创建新 VM
- ❌ 运行态克隆状态管理
- ❌ 克隆进度查询

## 3. 技术实现

### 3.1 KubeVirt 支持

KubeVirt 提供 `VirtualMachineSnapshot` 和 `VirtualMachineClone` API：

```yaml
# 1. 创建运行中 VM 的快照
apiVersion: snapshot.kubevirt.io/v1alpha1
kind: VirtualMachineSnapshot
metadata:
  name: running-vm-snapshot
spec:
  source:
    apiGroup: kubevirt.io
    kind: VirtualMachineInstance
    name: running-vm
---
# 2. 基于快照创建新 VM
apiVersion: clone.kubevirt.io/v1alpha1
kind: VirtualMachineClone
metadata:
  name: clone-from-vmi
spec:
  source:
    apiGroup: snapshot.kubevirt.io
    kind: VirtualMachineSnapshotContent
    name: running-vm-snapshot
  target:
    apiGroup: kubevirt.io
    kind: VirtualMachine
    name: cloned-vm
```

### 3.2 实现方案

```go
// pkg/kubevirt/vmis_clone.go

func CloneFromVMI(ctx context.Context, c client.Client, sourceVMI, targetVM string, namespace string) error {
    logger := log.FromContext(ctx)
    
    // 1. 检查源 VMI 是否存在且运行中
    vmi := &kubevirtv1.VirtualMachineInstance{}
    key := client.ObjectKey{Name: sourceVMI, Namespace: namespace}
    if err := c.Get(ctx, key, vmi); err != nil {
        return fmt.Errorf("VMI not found: %w", err)
    }
    
    if vmi.Status.Phase != kubevirtv1.Running {
        return fmt.Errorf("VMI is not running (phase: %s)", vmi.Status.Phase)
    }
    
    // 2. 创建快照
    snapshotName := fmt.Sprintf("snapshot-%s-%d", sourceVMI, time.Now().Unix())
    snapshot, err := createVMISnapshot(ctx, c, sourceVMI, snapshotName, namespace)
    if err != nil {
        return fmt.Errorf("failed to create snapshot: %w", err)
    }
    
    logger.Info("Created snapshot for running VMI", "snapshot", snapshotName, "vmi", sourceVMI)
    
    // 3. 等待快照完成
    if err := waitForSnapshotReady(ctx, c, snapshotName, namespace); err != nil {
        return fmt.Errorf("snapshot not ready: %w", err)
    }
    
    // 4. 基于快照创建新 VM
    return cloneFromSnapshot(ctx, c, snapshotName, targetVM, namespace)
}

func createVMISnapshot(ctx context.Context, c client.Client, vmiName, snapshotName, namespace string) (*snapshotv1alpha1.VirtualMachineSnapshot, error) {
    snapshot := &snapshotv1alpha1.VirtualMachineSnapshot{
        ObjectMeta: metav1.ObjectMeta{
            Name:      snapshotName,
            Namespace: namespace,
        },
        Spec: snapshotv1alpha1.VirtualMachineSnapshotSpec{
            Source: corev1.TypedLocalObjectReference{
                APIGroup: &apiGroup,
                Kind:     "VirtualMachineInstance",
                Name:     vmiName,
            },
        },
    }
    return snapshot, c.Create(ctx, snapshot)
}
```

## 4. API 设计

### 4.1 WukongSpec 扩展

```go
// api/v1alpha1/wukong_types.go

type CloneSourceSpec struct {
    // ... 现有字段 ...
    
    // VMIName 源 VMI 名称（用于运行态克隆）
    // +optional
    VMIName string `json:"vmiName,omitempty"`
    
    // CloneType 克隆类型: full, linked, running
    // +optional
    CloneType string `json:"cloneType,omitempty"` // running 表示运行态克隆
}
```

### 4.2 使用示例

```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: cloned-from-running
spec:
  cpu: 2
  memory: 4Gi
  cloneSource:
    type: vmi
    vmiName: running-vm
    cloneType: running  # 运行态克隆
  disks:
  - name: system
    size: 20Gi
```

## 5. 实现步骤

### 5.1 第一阶段：基础功能
1. 支持基于运行中 VMI 创建快照
2. 基于快照创建新 VM
3. 实现状态查询

### 5.2 第二阶段：优化
1. 自动清理临时快照
2. 支持进度查询
3. 错误处理和重试

### 5.3 第三阶段：高级特性
1. 支持选择性克隆（仅克隆指定磁盘）
2. 支持跨命名空间克隆
3. 支持批量运行态克隆

## 6. 使用示例

### 6.1 基本运行态克隆
```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: cloned-vm
spec:
  cpu: 2
  memory: 4Gi
  cloneSource:
    type: vmi
    vmiName: source-vm
    namespace: default
    cloneType: running
  disks:
  - name: system
    size: 20Gi
```

### 6.2 从 VM 运行态克隆
```yaml
# 如果源是 VirtualMachine，需要先启动 VMI
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: cloned-from-vm
spec:
  cpu: 2
  memory: 4Gi
  cloneSource:
    type: vm
    vmName: source-vm
    cloneType: running  # 自动启动 VMI 并克隆
  disks:
  - name: system
    size: 20Gi
```

## 7. Controller 实现

```go
// internal/controller/wukong_controller.go

func (r *WukongReconciler) cloneFromRunningVMI(ctx context.Context, vmp *vmv1alpha1.Wukong) error {
    logger := log.FromContext(ctx)
    
    sourceVMI := vmp.Spec.CloneSource.VMIName
    namespace := vmp.Spec.CloneSource.Namespace
    if namespace == "" {
        namespace = vmp.Namespace
    }
    
    // 1. 检查源 VMI
    vmi := &kubevirtv1.VirtualMachineInstance{}
    key := client.ObjectKey{Name: sourceVMI, Namespace: namespace}
    if err := r.Get(ctx, key, vmi); err != nil {
        return fmt.Errorf("VMI not found: %w", err)
    }
    
    // 2. 创建快照
    snapshotName := fmt.Sprintf("snapshot-%s-%s", sourceVMI, vmp.Name)
    snapshot, err := r.createVMISnapshot(ctx, sourceVMI, snapshotName, namespace)
    if err != nil {
        return err
    }
    
    // 3. 更新状态
    vmp.Status.CloneStatus = &vmv1alpha1.CloneStatus{
        Phase:     "Cloning",
        Progress:  "0%",
        SourceVMI: sourceVMI,
    }
    r.Status().Update(ctx, vmp)
    
    // 4. 等待快照完成
    if err := r.waitForSnapshotReady(ctx, snapshotName, namespace); err != nil {
        return err
    }
    
    // 5. 基于快照创建磁盘
    for _, disk := range vmp.Spec.Disks {
        if err := r.cloneDiskFromSnapshot(ctx, snapshotName, disk, vmp.Namespace, vmp.Name); err != nil {
            return err
        }
    }
    
    // 6. 更新状态
    vmp.Status.CloneStatus.Phase = "Succeeded"
    vmp.Status.CloneStatus.Progress = "100%"
    return r.Status().Update(ctx, vmp)
}
```

## 8. 注意事项

### 8.1 存储后端要求
- 需要存储后端支持在线快照（Longhorn、Ceph 等）
- 检查 VolumeSnapshotClass 配置
- 验证存储驱动支持

### 8.2 数据一致性
- 快照创建时可能有短暂的数据不一致
- 建议在应用层处理数据一致性
- 支持应用级别的快照触发

### 8.3 性能影响
- 快照创建可能影响源 VM 性能
- 大磁盘快照耗时较长
- 考虑在低峰期执行

### 8.4 资源管理
- 快照占用存储空间
- 及时清理临时快照
- 监控存储使用情况

## 9. 面试要点

### 9.1 运行态克隆和普通克隆的区别？

**答案**:
- **运行态克隆**: 源 VM 继续运行，基于快照，零停机，需要存储后端支持
- **普通克隆**: 需要停止源 VM，完全复制数据，所有存储都支持

### 9.2 如何保证运行态克隆的数据一致性？

**答案**:
- 使用存储后端的快照功能（时间点快照）
- 在应用层处理数据一致性（如数据库事务）
- 支持应用级别的快照触发
- 记录快照时间点

### 9.3 运行态克隆的性能优化？

**答案**:
- 使用增量快照（如果支持）
- 并行克隆多个磁盘
- 在低峰期执行克隆
- 使用高性能存储后端

