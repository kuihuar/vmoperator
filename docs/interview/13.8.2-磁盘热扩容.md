# 磁盘热扩容

## 1. 功能概述

### 1.1 磁盘热扩容
在 VM 运行过程中扩容磁盘，无需重启 VM。

**使用场景**:
- 磁盘空间不足时扩容
- 业务增长需要更多存储
- 避免停机维护
- 动态调整存储资源

### 1.2 扩容流程
1. 扩容 PVC（存储后端）
2. 扩容 VM 内的分区/文件系统
3. 验证扩容结果

## 2. 当前实现状态

### 2.1 已实现
- ✅ **静态配置**: 创建时配置磁盘大小
- ✅ **PVC 扩容**: 支持 PVC 扩容（存储后端支持）

### 2.2 待实现
- ❌ **自动文件系统扩容**: 自动扩容 VM 内文件系统
- ❌ **扩容验证**: 验证扩容是否成功
- ❌ **扩容策略**: 自动扩容策略
- ❌ **多磁盘扩容**: 支持多个磁盘同时扩容

## 3. 技术实现

### 3.1 存储后端支持

#### Longhorn 支持
- Longhorn 支持 PVC 扩容
- 通过修改 PVC 的 `spec.resources.requests.storage`
- 自动触发 Longhorn Volume 扩容

#### Ceph 支持
- Ceph 支持 PVC 扩容
- 通过 RBD 或 CephFS 扩容
- 需要存储池有足够空间

### 3.2 实现方案

```go
// pkg/storage/scaling.go

func ExpandDisk(ctx context.Context, c client.Client, diskName, namespace string, newSize string) error {
    logger := log.FromContext(ctx)
    
    // 1. 获取 PVC
    pvc := &corev1.PersistentVolumeClaim{}
    key := client.ObjectKey{Name: diskName, Namespace: namespace}
    if err := c.Get(ctx, key, pvc); err != nil {
        return fmt.Errorf("PVC not found: %w", err)
    }
    
    // 2. 解析新大小
    newQuantity, err := resource.ParseQuantity(newSize)
    if err != nil {
        return fmt.Errorf("invalid size format: %w", err)
    }
    
    // 3. 检查新大小是否大于当前大小
    currentSize := pvc.Spec.Resources.Requests[corev1.ResourceStorage]
    if newQuantity.Cmp(currentSize) <= 0 {
        return fmt.Errorf("new size must be greater than current size")
    }
    
    // 4. 更新 PVC 大小
    pvc.Spec.Resources.Requests[corev1.ResourceStorage] = newQuantity
    if err := c.Update(ctx, pvc); err != nil {
        return fmt.Errorf("failed to update PVC: %w", err)
    }
    
    logger.Info("PVC expanded", "pvc", diskName, "newSize", newSize)
    
    // 5. 等待 PVC 扩容完成
    if err := waitForPVCExpanded(ctx, c, diskName, namespace, newSize); err != nil {
        return fmt.Errorf("PVC expansion timeout: %w", err)
    }
    
    // 6. 扩容 VM 内文件系统
    return expandFilesystem(ctx, c, diskName, namespace)
}

func waitForPVCExpanded(ctx context.Context, c client.Client, pvcName, namespace, expectedSize string) error {
    deadline := time.Now().Add(5 * time.Minute)
    ticker := time.NewTicker(5 * time.Second)
    defer ticker.Stop()
    
    expectedQuantity, _ := resource.ParseQuantity(expectedSize)
    
    for {
        select {
        case <-ctx.Done():
            return ctx.Err()
        case <-ticker.C:
            if time.Now().After(deadline) {
                return fmt.Errorf("timeout waiting for PVC expansion")
            }
            
            pvc := &corev1.PersistentVolumeClaim{}
            key := client.ObjectKey{Name: pvcName, Namespace: namespace}
            if err := c.Get(ctx, key, pvc); err != nil {
                return err
            }
            
            // 检查 PVC 状态
            if pvc.Status.Capacity != nil {
                currentSize := pvc.Status.Capacity[corev1.ResourceStorage]
                if currentSize.Cmp(expectedQuantity) >= 0 {
                    return nil
                }
            }
        }
    }
}

func expandFilesystem(ctx context.Context, c client.Client, diskName, namespace string) error {
    // 1. 获取 VMI
    vmi := &kubevirtv1.VirtualMachineInstance{}
    // 需要通过磁盘名找到对应的 VMI
    // 这里简化处理，实际需要查询所有 VMI
    
    // 2. 通过 QEMU Guest Agent 或 SSH 执行文件系统扩容命令
    // 例如：resize2fs /dev/sda1
    
    // 方案一：通过 QEMU Guest Agent
    return expandFilesystemViaGuestAgent(ctx, c, vmi, diskName)
    
    // 方案二：通过 SSH（需要配置 SSH 密钥）
    // return expandFilesystemViaSSH(ctx, vmi, diskName)
}

func expandFilesystemViaGuestAgent(ctx context.Context, c client.Client, vmi *kubevirtv1.VirtualMachineInstance, diskName string) error {
    // 检查是否有 QEMU Guest Agent
    if !hasGuestAgent(vmi) {
        return fmt.Errorf("QEMU Guest Agent not available")
    }
    
    // 通过 VMI 的 QEMU Guest Agent 执行命令
    // 注意：KubeVirt 可能不直接支持通过 API 执行命令
    // 可能需要通过其他方式（如 SSH 或自定义工具）
    
    // 这里需要根据实际实现方式调整
    return nil
}
```

### 3.3 Controller 实现

```go
// internal/controller/wukong_controller.go

func (r *WukongReconciler) reconcileDiskScaling(ctx context.Context, vmp *vmv1alpha1.Wukong) error {
    logger := log.FromContext(ctx)
    
    // 检查每个磁盘是否需要扩容
    for _, disk := range vmp.Spec.Disks {
        // 查找对应的 VolumeStatus
        var volStatus *vmv1alpha1.VolumeStatus
        for i := range vmp.Status.Volumes {
            if vmp.Status.Volumes[i].Name == disk.Name {
                volStatus = &vmp.Status.Volumes[i]
                break
            }
        }
        
        if volStatus == nil {
            continue
        }
        
        // 比较当前大小和期望大小
        currentSize := volStatus.Size
        desiredSize := disk.Size
        
        if currentSize != desiredSize {
            logger.Info("Disk scaling detected", "disk", disk.Name, "current", currentSize, "desired", desiredSize)
            
            // 检查是否为扩容（不支持缩容）
            if !isSizeGreater(desiredSize, currentSize) {
                return fmt.Errorf("disk shrinking is not supported: %s", disk.Name)
            }
            
            // 执行扩容
            if err := r.expandDisk(ctx, disk.Name, volStatus.PVCName, vmp.Namespace, desiredSize); err != nil {
                return fmt.Errorf("failed to expand disk %s: %w", disk.Name, err)
            }
            
            // 更新状态
            volStatus.Size = desiredSize
        }
    }
    
    return r.Status().Update(ctx, vmp)
}

func (r *WukongReconciler) expandDisk(ctx context.Context, diskName, pvcName, namespace, newSize string) error {
    // 1. 扩容 PVC
    if err := storage.ExpandDisk(ctx, r.Client, pvcName, namespace, newSize); err != nil {
        return err
    }
    
    // 2. 获取 VMI
    vmName := fmt.Sprintf("%s-vm", diskName) // 简化处理，实际需要从 Wukong 获取
    vmi := &kubevirtv1.VirtualMachineInstance{}
    key := client.ObjectKey{Name: vmName, Namespace: namespace}
    if err := r.Get(ctx, key, vmi); err != nil {
        // VMI 不存在，可能未运行，记录日志
        return nil
    }
    
    // 3. 扩容文件系统（如果 VMI 运行中）
    if vmi.Status.Phase == kubevirtv1.Running {
        return r.expandFilesystemInVM(ctx, vmi, diskName)
    }
    
    return nil
}
```

## 4. API 设计

### 4.1 使用示例

```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: my-vm
spec:
  cpu: 2
  memory: 4Gi
  disks:
  - name: system
    size: 50Gi  # 从 20Gi 扩容到 50Gi
  - name: data
    size: 200Gi  # 从 100Gi 扩容到 200Gi
```

### 4.2 扩容策略

```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: my-vm
spec:
  cpu: 2
  memory: 4Gi
  disks:
  - name: system
    size: 50Gi
    scalingPolicy:
      enableHotExpand: true
      maxSize: 100Gi
```

## 5. 文件系统扩容

### 5.1 Linux 系统

```bash
# 对于 ext2/ext3/ext4 文件系统
resize2fs /dev/sda1

# 对于 xfs 文件系统
xfs_growfs /dev/sda1

# 对于 LVM
lvextend -L +30G /dev/vg0/lv0
resize2fs /dev/vg0/lv0
```

### 5.2 Windows 系统

```powershell
# 扩展磁盘分区
Resize-Partition -DriveLetter C -Size (Get-PartitionSupportedSize -DriveLetter C).SizeMax
```

## 6. 注意事项

### 6.1 存储后端限制
- 需要存储后端支持 PVC 扩容
- 检查存储池是否有足够空间
- 某些存储可能不支持在线扩容

### 6.2 文件系统限制
- 需要 VM 内操作系统支持
- 某些文件系统可能不支持在线扩容
- 需要 root 权限执行扩容命令

### 6.3 数据安全
- 扩容前建议备份数据
- 确保有足够的存储空间
- 验证扩容后的数据完整性
- 提供回滚机制

### 6.4 不支持缩容
- 磁盘不支持缩容（数据安全考虑）
- 需要删除后重建
- 提供数据迁移方案

## 7. 面试要点

### 7.1 磁盘热扩容的实现流程？

**答案**:
1. 扩容 PVC（存储后端）
2. 等待 PVC 扩容完成
3. 在 VM 内扩容文件系统
4. 验证扩容结果

### 7.2 如何自动扩容 VM 内的文件系统？

**答案**:
- 通过 QEMU Guest Agent 执行命令
- 通过 SSH 执行命令
- 使用 Cloud-Init 脚本
- 使用自定义工具或 Operator

### 7.3 为什么磁盘不支持缩容？

**答案**:
- 数据安全考虑（可能丢失数据）
- 文件系统不支持在线缩容
- 需要重新分区和格式化
- 提供数据迁移方案作为替代

