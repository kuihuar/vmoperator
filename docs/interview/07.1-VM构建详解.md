# VM 构建详解

## 1. buildVirtualMachine 函数

### 1.1 函数签名

```go
func buildVirtualMachine(ctx context.Context, c client.Client, vmp *vmv1alpha1.Wukong, 
    networks []vmv1alpha1.NetworkStatus, volumes []vmv1alpha1.VolumeStatus) *kubevirtv1.VirtualMachine
```

### 1.2 构建流程

```go
func buildVirtualMachine(ctx context.Context, c client.Client, vmp *vmv1alpha1.Wukong, 
    networks []vmv1alpha1.NetworkStatus, volumes []vmv1alpha1.VolumeStatus) *kubevirtv1.VirtualMachine {
    
    vmName := fmt.Sprintf("%s-vm", vmp.Name)
    
    // 1. 创建 VirtualMachine 对象
    vm := &kubevirtv1.VirtualMachine{
        ObjectMeta: metav1.ObjectMeta{
            Name:      vmName,
            Namespace: vmp.Namespace,
        },
        Spec: buildVMSpec(ctx, c, vmp, networks, volumes),
    }
    
    // 2. 设置 OwnerReference
    if vmp.UID != "" {
        vm.OwnerReferences = []metav1.OwnerReference{...}
    }
    
    // 3. 设置网络注解（Multus）
    annotations := buildNetworkAnnotations(networks)
    if len(annotations) > 0 {
        vm.Annotations = annotations
    }
    
    return vm
}
```

## 2. buildVMSpec 函数

### 2.1 基本结构

```go
func buildVMSpec(ctx context.Context, c client.Client, vmp *vmv1alpha1.Wukong, 
    networks []vmv1alpha1.NetworkStatus, volumes []vmv1alpha1.VolumeStatus) kubevirtv1.VirtualMachineSpec {
    
    // 1. 确定是否自动启动
    autoStart := true
    if vmp.Spec.StartStrategy != nil {
        autoStart = vmp.Spec.StartStrategy.AutoStart
    }
    
    // 2. 解析内存
    memoryQuantity, err := resource.ParseQuantity(vmp.Spec.Memory)
    
    // 3. 构建 template
    template := &kubevirtv1.VirtualMachineInstanceTemplateSpec{
        Spec: kubevirtv1.VirtualMachineInstanceSpec{
            Domain: kubevirtv1.DomainSpec{
                CPU:    &kubevirtv1.CPU{Cores: uint32(vmp.Spec.CPU)},
                Memory: &kubevirtv1.Memory{Guest: &memoryQuantity},
                Devices: kubevirtv1.Devices{
                    Disks:      buildDisks(volumes),
                    Interfaces: buildInterfaces(networks),
                },
            },
            Networks: buildNetworks(networks),
            Volumes:  buildVolumes(volumes),
        },
    }
    
    // 4. 添加 Cloud-Init 配置
    // 5. 添加调度策略
    
    return kubevirtv1.VirtualMachineSpec{
        Running:  &autoStart,
        Template: template,
    }
}
```

## 3. CPU 和内存配置

### 3.1 CPU 配置

```go
CPU: &kubevirtv1.CPU{
    Cores: uint32(vmp.Spec.CPU),
}
```

**说明**: 直接使用 Wukong Spec 中的 CPU 值

### 3.2 内存配置

```go
memoryQuantity, err := resource.ParseQuantity(vmp.Spec.Memory)
if err != nil {
    memoryQuantity = resource.MustParse("2Gi") // 默认值
}

Memory: &kubevirtv1.Memory{
    Guest: &memoryQuantity,
}
```

**说明**: 解析内存字符串（如 "8Gi"）为 Quantity

## 4. 自动启动配置

### 4.1 Running 字段

```go
autoStart := true
if vmp.Spec.StartStrategy != nil {
    autoStart = vmp.Spec.StartStrategy.AutoStart
}

spec := kubevirtv1.VirtualMachineSpec{
    Running:  &autoStart,
    Template: template,
}
```

**说明**:
- `Running: true`: 创建后自动启动
- `Running: false`: 创建后不启动，需要手动启动

## 5. 调度策略配置

### 5.1 NodeSelector

```go
if vmp.Spec.HighAvailability != nil {
    if len(vmp.Spec.HighAvailability.NodeSelector) > 0 {
        template.Spec.NodeSelector = vmp.Spec.HighAvailability.NodeSelector
    }
}
```

### 5.2 Tolerations

```go
if len(vmp.Spec.HighAvailability.Tolerations) > 0 {
    tolerations := make([]corev1.Toleration, 0, len(vmp.Spec.HighAvailability.Tolerations))
    for _, tol := range vmp.Spec.HighAvailability.Tolerations {
        tolerations = append(tolerations, corev1.Toleration{
            Key:      tol.Key,
            Operator: corev1.TolerationOperator(tol.Operator),
            Value:    tol.Value,
            Effect:   corev1.TaintEffect(tol.Effect),
        })
    }
    template.Spec.Tolerations = tolerations
}
```

## 6. 网络注解

### 6.1 buildNetworkAnnotations

```go
func buildNetworkAnnotations(networks []vmv1alpha1.NetworkStatus) map[string]string {
    annotations := make(map[string]string)
    netList := make([]map[string]string, 0, len(networks))
    
    for i, net := range networks {
        if net.NADName != "" {
            netList = append(netList, map[string]string{
                "name":      net.NADName,
                "interface": fmt.Sprintf("net%d", i+1),
            })
        }
    }
    
    if len(netList) > 0 {
        netJSON, _ := json.Marshal(netList)
        annotations["k8s.v1.cni.cncf.io/networks"] = string(netJSON)
    }
    
    return annotations
}
```

**说明**: Multus CNI 使用注解来配置多网络接口

## 7. 面试要点

### 7.1 VM Spec 的构建顺序？

**答案**:
1. 配置 CPU 和内存
2. 构建网络接口和网络定义
3. 构建存储卷和磁盘设备
4. 添加 Cloud-Init 配置
5. 配置调度策略

### 7.2 为什么需要设置 Running 字段？

**答案**:
- 控制 VM 是否自动启动
- 支持手动启动的场景
- 与 StartStrategy 配置配合使用

### 7.3 网络注解的作用？

**答案**:
- Multus CNI 通过注解识别多网络配置
- 注解格式: `k8s.v1.cni.cncf.io/networks`
- 包含 NAD 名称和接口名称的映射

