# 端口映射与 Service 暴露

## 1. 功能概述

### 1.1 端口映射
将 VM 内的端口映射到节点端口或通过 Service 暴露，使外部可以访问 VM 内的服务。

**使用场景**:
- 暴露 Web 服务
- 暴露数据库服务
- 暴露 API 服务
- 临时访问 VM 服务

### 1.2 Service 暴露
通过 Kubernetes Service 暴露 VM 服务，支持 ClusterIP、NodePort、LoadBalancer 等类型。

**使用场景**:
- 集群内服务访问
- 外部访问 VM 服务
- 负载均衡
- 服务发现

## 2. 当前实现状态

### 2.1 已实现
- ❌ 无端口映射功能
- ❌ 无 Service 暴露功能

### 2.2 待实现
- ❌ **端口映射**: 映射 VM 端口到节点
- ❌ **Service创建**: 自动创建 Service
- ❌ **多端口支持**: 支持多个端口映射
- ❌ **负载均衡**: 多个 VM 的负载均衡

## 3. 技术实现

### 3.1 端口映射实现

#### 方案一：使用 HostPort
```go
// pkg/kubevirt/port_mapping.go

func AddPortMapping(vmi *kubevirtv1.VirtualMachineInstance, portMapping PortMapping) {
    // 在 VMI 的 Domain 中添加端口映射
    // 注意：KubeVirt 可能不直接支持 HostPort，需要通过其他方式
}
```

#### 方案二：使用 NodePort Service
```go
// pkg/kubevirt/service_exposure.go

func CreateNodePortService(ctx context.Context, c client.Client, vmName, namespace string, portMappings []PortMapping) error {
    service := &corev1.Service{
        ObjectMeta: metav1.ObjectMeta{
            Name:      fmt.Sprintf("%s-nodeport", vmName),
            Namespace: namespace,
        },
        Spec: corev1.ServiceSpec{
            Type: corev1.ServiceTypeNodePort,
            Selector: map[string]string{
                "kubevirt.io/vm": vmName,
            },
            Ports: buildServicePorts(portMappings),
        },
    }
    
    return c.Create(ctx, service)
}
```

### 3.2 Service 暴露实现

```go
// pkg/kubevirt/service_exposure.go

type ServiceExposureSpec struct {
    // Type Service 类型: ClusterIP, NodePort, LoadBalancer
    Type string `json:"type"`
    
    // Ports 端口映射列表
    Ports []PortMapping `json:"ports"`
    
    // Selector 选择器（可选，默认使用 VM 标签）
    // +optional
    Selector map[string]string `json:"selector,omitempty"`
}

type PortMapping struct {
    // Name 端口名称
    Name string `json:"name"`
    
    // Protocol 协议: TCP, UDP
    Protocol string `json:"protocol"`
    
    // Port Service 端口
    Port int32 `json:"port"`
    
    // TargetPort VM 内端口
    TargetPort int32 `json:"targetPort"`
    
    // NodePort NodePort 端口（NodePort 类型需要）
    // +optional
    NodePort *int32 `json:"nodePort,omitempty"`
}

func CreateService(ctx context.Context, c client.Client, vmName, namespace string, spec ServiceExposureSpec) error {
    service := &corev1.Service{
        ObjectMeta: metav1.ObjectMeta{
            Name:      fmt.Sprintf("%s-service", vmName),
            Namespace: namespace,
        },
        Spec: corev1.ServiceSpec{
            Type:     corev1.ServiceType(spec.Type),
            Selector: buildSelector(vmName, spec.Selector),
            Ports:    buildServicePorts(spec.Ports),
        },
    }
    
    return c.Create(ctx, service)
}

func buildServicePorts(portMappings []PortMapping) []corev1.ServicePort {
    ports := make([]corev1.ServicePort, 0, len(portMappings))
    for _, pm := range portMappings {
        port := corev1.ServicePort{
            Name:       pm.Name,
            Protocol:   corev1.Protocol(pm.Protocol),
            Port:       pm.Port,
            TargetPort: intstr.FromInt(int(pm.TargetPort)),
        }
        if pm.NodePort != nil {
            port.NodePort = *pm.NodePort
        }
        ports = append(ports, port)
    }
    return ports
}
```

## 4. API 设计

### 4.1 WukongSpec 扩展

```go
// api/v1alpha1/wukong_types.go

type NetworkConfig struct {
    // ... 现有字段 ...
    
    // ServiceExposure Service 暴露配置（可选）
    // +optional
    ServiceExposure *ServiceExposureSpec `json:"serviceExposure,omitempty"`
    
    // PortMappings 端口映射配置（可选）
    // +optional
    PortMappings []PortMappingSpec `json:"portMappings,omitempty"`
}

type ServiceExposureSpec struct {
    // Enabled 是否启用 Service 暴露
    Enabled bool `json:"enabled"`
    
    // Type Service 类型: ClusterIP, NodePort, LoadBalancer
    Type string `json:"type"`
    
    // Ports 端口列表
    Ports []ServicePortSpec `json:"ports"`
    
    // LoadBalancerIP LoadBalancer IP（LoadBalancer 类型）
    // +optional
    LoadBalancerIP *string `json:"loadBalancerIP,omitempty"`
}

type ServicePortSpec struct {
    // Name 端口名称
    Name string `json:"name"`
    
    // Protocol 协议: TCP, UDP
    Protocol string `json:"protocol"`
    
    // Port Service 端口
    Port int32 `json:"port"`
    
    // TargetPort VM 内端口
    TargetPort int32 `json:"targetPort"`
    
    // NodePort NodePort 端口（NodePort 类型）
    // +optional
    NodePort *int32 `json:"nodePort,omitempty"`
}
```

### 4.2 Controller 实现

```go
// internal/controller/wukong_controller.go

func (r *WukongReconciler) reconcileServiceExposure(ctx context.Context, vmp *vmv1alpha1.Wukong) error {
    logger := log.FromContext(ctx)
    vmName := fmt.Sprintf("%s-vm", vmp.Name)
    
    // 检查是否需要创建 Service
    var serviceSpec *vmv1alpha1.ServiceExposureSpec
    for _, net := range vmp.Spec.Networks {
        if net.ServiceExposure != nil && net.ServiceExposure.Enabled {
            serviceSpec = net.ServiceExposure
            break
        }
    }
    
    if serviceSpec == nil {
        // 删除现有的 Service（如果存在）
        return r.deleteService(ctx, vmName, vmp.Namespace)
    }
    
    // 创建或更新 Service
    service := &corev1.Service{}
    key := client.ObjectKey{Name: fmt.Sprintf("%s-service", vmName), Namespace: vmp.Namespace}
    
    if err := r.Get(ctx, key, service); err != nil {
        if errors.IsNotFound(err) {
            // 创建新 Service
            return r.createService(ctx, vmName, vmp, serviceSpec)
        }
        return err
    }
    
    // 更新现有 Service
    return r.updateService(ctx, service, serviceSpec)
}

func (r *WukongReconciler) createService(ctx context.Context, vmName string, vmp *vmv1alpha1.Wukong, spec *vmv1alpha1.ServiceExposureSpec) error {
    service := &corev1.Service{
        ObjectMeta: metav1.ObjectMeta{
            Name:      fmt.Sprintf("%s-service", vmName),
            Namespace: vmp.Namespace,
            OwnerReferences: []metav1.OwnerReference{
                {
                    APIVersion: vmp.APIVersion,
                    Kind:       vmp.Kind,
                    Name:       vmp.Name,
                    UID:        vmp.UID,
                    Controller: &[]bool{true}[0],
                },
            },
        },
        Spec: corev1.ServiceSpec{
            Type:     corev1.ServiceType(spec.Type),
            Selector: map[string]string{
                "kubevirt.io/vm": vmName,
            },
            Ports: buildServicePorts(spec.Ports),
        },
    }
    
    if spec.Type == "LoadBalancer" && spec.LoadBalancerIP != nil {
        service.Spec.LoadBalancerIP = *spec.LoadBalancerIP
    }
    
    return r.Create(ctx, service)
}
```

## 5. 使用示例

### 5.1 NodePort Service
```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: web-server
spec:
  cpu: 2
  memory: 4Gi
  networks:
  - name: eth0
    type: bridge
    serviceExposure:
      enabled: true
      type: NodePort
      ports:
      - name: http
        protocol: TCP
        port: 80
        targetPort: 8080
        nodePort: 30080
```

### 5.2 LoadBalancer Service
```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: api-server
spec:
  networks:
  - name: eth0
    type: bridge
    serviceExposure:
      enabled: true
      type: LoadBalancer
      ports:
      - name: https
        protocol: TCP
        port: 443
        targetPort: 8443
      loadBalancerIP: "192.168.1.100"
```

### 5.3 多端口暴露
```yaml
apiVersion: vm.novasphere.dev/v1alpha1
kind: Wukong
metadata:
  name: multi-port-vm
spec:
  networks:
  - name: eth0
    type: bridge
    serviceExposure:
      enabled: true
      type: NodePort
      ports:
      - name: http
        protocol: TCP
        port: 80
        targetPort: 8080
      - name: https
        protocol: TCP
        port: 443
        targetPort: 8443
      - name: ssh
        protocol: TCP
        port: 22
        targetPort: 22
```

## 6. 注意事项

### 6.1 Service 选择器
- 需要正确设置选择器指向 VM
- 使用 VMI 的标签作为选择器
- 确保 Endpoints 正确创建

### 6.2 端口冲突
- NodePort 端口可能冲突
- 需要检查端口可用性
- 提供自动分配端口选项

### 6.3 安全考虑
- 暴露端口需要考虑安全风险
- 使用网络策略限制访问
- 考虑使用 Ingress 代替直接暴露

## 7. 面试要点

### 7.1 如何通过 Service 暴露 VM 服务？

**答案**:
- 创建 Service 指向 VMI 的 Pod IP
- 使用 VMI 标签作为选择器
- 支持 ClusterIP、NodePort、LoadBalancer 类型
- 通过 Endpoints 管理后端

### 7.2 NodePort 和 LoadBalancer 的区别？

**答案**:
- **NodePort**: 在所有节点上暴露端口，适合小规模部署
- **LoadBalancer**: 通过云提供商的负载均衡器暴露，适合生产环境

### 7.3 如何实现多 VM 的负载均衡？

**答案**:
- 使用相同的 Service 选择器
- 多个 VM 使用相同的标签
- Service 自动负载均衡到多个后端
- 支持会话亲和性配置

